<!DOCTYPE html>
<html lang="en">

<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1.0" name="viewport">

<title>SVM</title>
<meta content="" name="description">
<meta content="" name="keywords">

<!-- Favicons -->
<link href="assets/img/Favicon-1.png" rel="icon">
<link href="assets/img/Favicon-1.png" rel="apple-touch-icon">

<!-- Google Fonts -->
<link href="https://fonts.googleapis.com/css?family=Open+Sans:300,300i,400,400i,600,600i,700,700i|Raleway:300,300i,400,400i,500,500i,600,600i,700,700i|Poppins:300,300i,400,400i,500,500i,600,600i,700,700i" rel="stylesheet">

<!-- Vendor CSS Files -->
<link href="assets/vendor/aos/aos.css" rel="stylesheet">
<link href="assets/vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">
<link href="assets/vendor/bootstrap-icons/bootstrap-icons.css" rel="stylesheet">
<link href="assets/vendor/boxicons/css/boxicons.min.css" rel="stylesheet">
<link href="assets/vendor/glightbox/css/glightbox.min.css" rel="stylesheet">
<link href="assets/vendor/swiper/swiper-bundle.min.css" rel="stylesheet">
<!-- Creating a python code section-->
<link rel="stylesheet" href="assets/css/prism.css">
<script src="assets/js/prism.js"></script>

<!-- Template Main CSS File -->
<link href="assets/css/style.css" rel="stylesheet">

<!-- To set the icon, visit https://fontawesome.com/account-->
<script src="https://kit.fontawesome.com/5d25c1efd3.js" crossorigin="anonymous"></script>
<!-- end of icon-->

<script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<!-- =======================================================
  * Template Name: iPortfolio
  * Updated: Sep 18 2023 with Bootstrap v5.3.2
  * Template URL: https://bootstrapmade.com/iportfolio-bootstrap-portfolio-websites-template/
  * Author: BootstrapMade.com
  * License: https://bootstrapmade.com/license/
======================================================== -->
</head>

<body>

<!-- ======= Mobile nav toggle button ======= -->
<i class="bi bi-list mobile-nav-toggle d-xl-none"></i>

<!-- ======= Header ======= -->
<header id="header">
<div class="d-flex flex-column">

    <div class="profile">
    <img src="assets/img/myphoto.jpeg" alt="" class="img-fluid rounded-circle">
    <h1 class="text-light"><a href="index.html">Arun</a></h1>
    <div class="social-links mt-3 text-center">
        <a href="https://www.linkedin.com/in/arunp77/" target="_blank" class="linkedin"><i class="bx bxl-linkedin"></i></a>
        <a href="https://github.com/arunp77" target="_blank" class="github"><i class="bx bxl-github"></i></a>
        <a href="https://twitter.com/arunp77_" target="_blank" class="twitter"><i class="bx bxl-twitter"></i></a>
        <a href="https://www.instagram.com/arunp77/" target="_blank" class="instagram"><i class="bx bxl-instagram"></i></a>
        <a href="https://arunp77.medium.com/" target="_blank" class="medium"><i class="bx bxl-medium"></i></a>
    </div>
    </div>

    <nav id="navbar" class="nav-menu navbar">
    <ul>
        <li><a href="index.html#hero" class="nav-link scrollto active"><i class="bx bx-home"></i> <span>Home</span></a></li>
        <li><a href="index.html#about" class="nav-link scrollto"><i class="bx bx-user"></i> <span>About</span></a></li>
        <li><a href="index.html#resume" class="nav-link scrollto"><i class="bx bx-file-blank"></i> <span>Resume</span></a></li>
        <li><a href="index.html#portfolio" class="nav-link scrollto"><i class="bx bx-book-content"></i> <span>Portfolio</span></a></li>
        <li><a href="index.html#skills-and-tools" class="nav-link scrollto"><i class="bx bx-wrench"></i> <span>Skills and Tools</span></a></li>
        <li><a href="index.html#services" class="nav-link scrollto"><i class="bx bx-server"></i> <span>Services</span></a></li>
        <li><a href="index.html#professionalcourses" class="nav-link scrollto"><i class="bx bx-book-alt"></i> <span>Professional Certification</span></a></li>
        <li><a href="index.html#publications" class="nav-link scrollto"><i class="bx bx-news"></i> <span>Publications</span></a></li>
        <li><a href="index.html#extra-curricular" class="nav-link scrollto"><i class="bx bx-rocket"></i> <span>Extra-Curricular Activities</span></a></li>
        <li><a href="index.html#contact" class="nav-link scrollto"><i class="bx bx-envelope"></i> <span>Contact</span></a></li>
    </ul>
    </nav><!-- .nav-menu -->
</div>
</header><!-- End Header -->

<main id="main">

    <!-- ======= Breadcrumbs ======= -->
    <section id="breadcrumbs" class="breadcrumbs">
    <div class="container">

    <div class="d-flex justify-content-between align-items-center">
        <h2>Machine Learning</h2>
        <ol>
        <li><a href="machine-learning.html" class="clickable-box">Content section</a></li>
        <li><a href="index.html#portfolio" class="clickable-box">Portfolio section</a></li>
        </ol>
    </div>

    </div>
    </section><!-- End Breadcrumbs -->

    <!------  right dropdown menue ------->
    <div class="right-side-list">
    <div class="dropdown">
        <button class="dropbtn"><strong>Shortcuts:</strong></button>
        <div class="dropdown-content">
            <ul>
                <li><a href="cloud-compute.html"><i class="fas fa-cloud"></i> Cloud</a></li>
                <li><a href="AWS-GCP.html"><i class="fas fa-cloud"></i> AWS-GCP</a></li>
                <li><a href="amazon-s3.html"><i class="fas fa-cloud"></i> AWS S3</a></li>
                <li><a href="ec2-confi.html"><i class="fas fa-server"></i> EC2</a></li>
                <li><a href="Docker-Container.html"><i class="fab fa-docker" style="color: rgb(29, 27, 27);"></i> Docker</a></li>
                <li><a href="Jupyter-nifi.html"><i class="fab fa-python" style="color: rgb(34, 32, 32);"></i> Jupyter-nifi</a></li>
                <li><a href="snowflake-task-stream.html"><i class="fas fa-snowflake"></i> Snowflake</a></li>
                <li><a href="data-model.html"><i class="fas fa-database"></i> Data modeling</a></li>
                <li><a href="sql-basics.html"><i class="fas fa-table"></i> QL</a></li>
                <li><a href="sql-basic-details.html"><i class="fas fa-database"></i> SQL</a></li>
                <li><a href="Bigquerry-sql.html"><i class="fas fa-database"></i> Bigquerry</a></li>
                <li><a href="scd.html"><i class="fas fa-archive"></i> SCD</a></li>
                <li><a href="sql-project.html"><i class="fas fa-database"></i> SQL project</a></li>
                <!-- Add more subsections as needed -->
            </ul>
        </div>
    </div>
    </div>

    <!-- ======= Portfolio Details Section ======= -->
    <section id="portfolio-details" class="portfolio-details">
    <div class="container">
    <div class="row gy-4">
        <h1>Support Vector Algorithm: Classification methods</h1>
        <div class="col-lg-8">
        <div class="portfolio-details-slider swiper">
            <div class="swiper-wrapper align-items-center">

                <figure>
                    <img src="assets/img/machine-ln/classification-svm.png" alt="" style="max-width: 100%; max-height: auto;">
                    <figcaption style="text-align: center;"></figcaption>
                </figure>

            </div>
        </div>
    </div>

    <div class="col-lg-4 grey-box">
        
        <div class="section-title">
        <h3>Content</h3>
        <ol>
            <li><a href="#introduction">Introduction</a>
                <ul>
                    <li><a href="#types-svm">Types of Support Vector Machine (SVM) Algorithms</a></li>
                    <li><a href="#terminology">Important terminologies</a></li>
                    <li><a href="#application">Useful application of SVM</a></li>
                    <li><a href="#intuition">Intuition: example</a></li>
                    <li><a href="#pros">Pros</a></li>
                    <li><a href="#cons">Cons</a></li>
                </ul>
            </li>
            <li><a href="#math-svm">Mathematical intuition behind the Support Vector Machine</a></li>
            <ul>
                <li><a href="#explanation-1">Example 1: Support-vector-machine explanation: 2D</a></li>
                <li><a href="#explanantion-2">Example 2: Classification problem with higher dimension data</a></li> 
                <li><a href="#kernel-fun">Kernel Functions</a></li>
                <li><a href="#purpose-kernel">Purpose of Kernel Functions</a></li>
                <li><a href="#types-kernel">Types of Kernel Functions</a></li>
            </ul>
            <li><a href="#steps-to-SVM">Step-by-step guide to performing Support Vector Machine (SVM)</a></li>
            <li><a href="#example-python">Example project</a></li>
            <li><a href="#reference">Reference</a></li>
        </ol>
        </div>
    </div>
    </div>

    <section>
    <!-------------------- Introduction ---------------------->
    <h2 id="introdction">Introduction</h2>
    <ul>
        <li>Support Vector Machine (SVM) is undoubtedly one of the most popular ML algorithms used by machine learning practitioners. It is a supervised machine learning algorithm that is robust to outliers and generalizes well in many cases. However, the intuitive idea behind SVM can be a bit tricky to understand for a beginner. The name in itself is quite intimidating, Support, Vector, and Machine.</li>
        <li>It is used for Classification as well as Regression problems. However, primarily, it is used for Classification problems in Machine Learning.</li>
        <li>In this algorithm, we try to find a hyperplane that best separates the two classes. It is to be noted that, it may seems that the SVM and logisitc regression are similar. Both the algorithms try to find the best hyperplane, but the main difference is logistic regression is a probabilistic approach whereas support vector machine is based on statistical approaches.</li>
        <li>Now the question is which hyperplane does it select? There can be an infinite number of hyperplanes passing through a point and classifying the two classes perfectly. So, which one is the best? Well, SVM does this by finding the maximum margin between the hyperplanes that means maximum distances between the two classes.</li>
    </ul>
    <div class="grey-box">
        <p><strong>Logistic Regression vs Support Vector Machine (SVM): </strong>
        Depending on the number of features you have you can either choose Logistic Regression or SVM. SVM works best when the dataset is small and complex. It is usually advisable to first use logistic regression and see how does it performs, if it fails to give a good accuracy you can go for SVM without any kernel. Logistic regression and SVM without any kernel have similar performance but depending on your features, one may be more efficient than the other.</p>
        <table>
            <tr>
                <th>Feature</th>
                <th>Logisitc Regression</th>
                <th>Support Vecotr Machine (SVM)</th>
            </tr>
            <tr>
                <td>Type</td>
                <td>Discriminative model</td>
                <td>Discriminative model</td>
            </tr>
            <tr>
                <td>Decision Boundary</td>
                <td>Linear or Non-linear</td>
                <td>Linear or Non-linear</td>
            </tr>
            <tr>
                <td>Interpretability</td>
                <td>Easy to interpret coefficients</td>
                <td>Less interpretable due to complex decision boundaries</td>
            </tr>
            <tr>
                <td>Training Speed</td>
                <td>Faster</td>
                <td>Slower, especially with large datasets</td>
            </tr>
            <tr>
                <td>Regularization</td>
                <td>L1 or L2 regularization</td>
                <td>Regularization via margin parameter (C)</td>
            </tr>
            <tr>
                <td>Handling Noise</td>
                <td>Sensitive to noisy data</td>
                <td>More robust to noisy data</td>
            </tr>
            <tr>
                <td>Scalability</td>
                <td>Suitable for large datasets</td>
                <td>Can be computationally expensive with large datasets</td>
            </tr>
            <tr>
                <td>Performance on Small Data</td>
                <td>May underperform if features are not linearly separable</td>
                <td>Can handle non-linear data well, even with small datasets</td>
            </tr>
            <tr>
                <td>Parameters to Tune</td>
                <td>Regularization strength, threshold</td>
                <td>Regularization parameter (C), kernel function, gamma</td>
            </tr>
            <tr>
                <td>Application Areas</td>
                <td>Commonly used in binary classification tasks and probability estimation</td>
                <td>Widely used in classification tasks with non-linear decision boundaries</td>
            </tr>
            <tr>
                <td>Implementation</td>
                <td>Available in most machine learning libraries</td>
                <td>Available in most machine learning libraries</td>
            </tr>
            
        </table>
    </div><br>

    <!--------------------------------->
    <h3 id="types-svm">Types of Support Vector Machine (SVM) Algorithms</h3>
    <p>Support Vector Machines (SVMs) offer various algorithms for classification and regression tasks, primarily distinguished by the types of decision boundaries they create and the techniques they employ for optimization. Here are some common types of SVM algorithms:</p>
    <ol>
        <li><strong>Linear SVM:</strong> This algorithm is used when the data is linearly separable. Perfectly linearly separable means that the data points can be classified into 2 classes by using a single straight line(if 2D). It aims to find the optimal hyperplane that separates the classes with the maximum margin.</li>

        <li><strong>Non-linear SVM:</strong> When the data is not linearly separable then we can use Non-Linear SVM, which means when the data points cannot be separated into 2 classes by using a straight line (if 2D) then we use some advanced techniques like kernel tricks to classify them. In most real-world applications we do not find linearly separable datapoints hence we use kernel trick to solve them.</li>
        
        <li><strong>Support Vector Regression (SVR):</strong> Unlike classification tasks, SVR is used for regression tasks. It aims to find the optimal hyperplane that best fits the data while minimizing the margin violations.</li>
        
        <li><strong>Nu-SVM:</strong> This algorithm is an extension of the traditional SVM, introducing a parameter "nu" that replaces the regularization parameter "C." It offers a more intuitive control over the number of support vectors and margin errors.</li>
        
        <li><strong>One-Class SVM:</strong> Primarily used for anomaly detection, this algorithm learns a decision boundary that encompasses the majority of the data points while treating the rest as outliers.</li>
        
        <li><strong>Sequential Minimal Optimization (SMO):</strong> SMO is an algorithm for training SVMs, particularly useful for solving large-scale optimization problems by decomposing them into smaller sub-problems.</li>
        
        <li><strong>Least Squares SVM (LS-SVM):</strong> This variant of SVM reformulates the optimization problem as a set of linear equations, making it computationally efficient for large-scale datasets.</li>
        
        <li><strong>Budgeted SVM:</strong> Designed for scenarios with limited computational resources, this algorithm dynamically selects a subset of support vectors to reduce computational complexity while maintaining classification accuracy.</li>
    </ol>

    <!---------------------------------------->
    <h3 id="terminology">Important terminologies</h3>
    <p>Here are some important terms in the context of Support Vector Machines (SVM):</p>
    <ul>
        <li><strong>Hyperplane:</strong> In SVM, a hyperplane is a decision boundary that separates classes in a feature space. For a binary classification problem, it's a line in 2D space, a plane in 3D space, and a higher-dimensional surface in higher dimensions.</li>
        <li><strong>Margin:</strong> The margin is the distance between the hyperplane and the nearest data points of each class. SVM aims to maximize this margin, as it represents the separation between classes. Maximizing the margin helps improve generalization and reduces the risk of overfitting.</li>
        <li><strong>Support Vectors:</strong> These are the data points that lie closest to the decision boundary (hyperplane). They determine the position and orientation of the hyperplane and are crucial in defining the margin. Only these points influence the construction of the hyperplane; hence, they are called support vectors.</li>
        <li><strong>Kernel Trick:</strong> SVMs can efficiently handle non-linear decision boundaries by using kernel functions. The kernel trick involves implicitly mapping the input features into a higher-dimensional space, where the classes are more likely to be separable. Common kernel functions include linear, polynomial, radial basis function (RBF), and sigmoid.</li>
        <li><strong>Regularization Parameter (C):</strong> The regularization parameter (C) controls the trade-off between maximizing the margin and minimizing the classification error. A smaller C value leads to a larger margin but may result in misclassification of some training examples (soft margin). Conversely, a larger C value allows more training examples to be correctly classified but may lead to a smaller margin (hard margin). Proper tuning of C is crucial to prevent overfitting.</li>
        <li><strong>Kernel Parameters:</strong> For kernelized SVMs, there are additional parameters to tune, such as gamma (\(\gamma\)) for RBF kernel and degree for polynomial kernel. These parameters control the flexibility of the decision boundary. Proper selection of kernel parameters is essential for achieving good performance and avoiding overfitting.</li>
        <li><strong>Dual Problem:</strong> The optimization problem in SVM can be reformulated into its dual form, which involves maximizing a function subject to constraints. Solving the dual problem is often more computationally efficient, especially when using kernel functions.</li>
        <li><strong>Nu Parameter:</strong> In Nu-SVM, the nu parameter replaces the C parameter and controls the upper bound on the fraction of margin errors and support vectors. It offers a more intuitive way to adjust the model complexity.</li>
    </ul>

    <!--------------------------------------->
    <h4 id="application">Useful application of SVM</h4>
    <p>Support Vector Machines (SVMs) are versatile algorithms that find applications in various fields due to their ability to handle both linear and non-linear classification problems efficiently. Here are some common applications of SVM:</p>
    <ul>
        <li><strong>Image Classification:</strong> SVMs are widely used in image classification tasks, such as identifying objects or scenes within images. They can efficiently handle high-dimensional feature spaces and are robust to noise.</li>

        <li><strong>Text Classification:</strong> SVMs are employed in text classification tasks, such as spam email detection, sentiment analysis, and document categorization. They can effectively classify text data represented as high-dimensional feature vectors.</li>
        
        <li><strong>Handwriting Recognition:</strong> SVMs are used in handwriting recognition systems, where they classify handwritten characters or digits into different classes. They can handle complex patterns and variations in handwriting styles.</li>
        
        <li><strong>Biomedical Applications:</strong> SVMs find applications in various biomedical tasks, including disease diagnosis, protein classification, and gene expression analysis. They can analyze high-dimensional biomedical data and identify patterns indicative of specific conditions.</li>
        
        <li><strong>Financial Forecasting:</strong> SVMs are utilized in financial forecasting tasks, such as stock price prediction, credit scoring, and fraud detection. They can analyze historical financial data and identify patterns to make predictions about future trends or events.</li>
        
        <li><strong>Bioinformatics:</strong> SVMs are applied in bioinformatics for tasks such as protein structure prediction, DNA sequence analysis, and protein-protein interaction prediction. They can handle large-scale biological data and extract meaningful patterns.</li>
        
        <li><strong>Remote Sensing:</strong> SVMs are used in remote sensing applications, such as land cover classification, crop classification, and environmental monitoring. They can analyze satellite imagery and classify different land cover types accurately.</li>
        
        <li><strong>Face Detection:</strong> SVMs are employed in face detection systems, where they classify image regions as containing faces or background. They can effectively distinguish between facial features and background clutter.</li>
        
        <li><strong>Medical Diagnosis:</strong> SVMs are used in medical diagnosis tasks, such as cancer detection, disease prognosis, and patient outcome prediction. They can analyze medical data from various sources and assist healthcare professionals in decision-making.</li>
        
        <li><strong>Anomaly Detection:</strong> SVMs are utilized in anomaly detection systems to identify unusual or unexpected patterns in data. They can detect outliers or anomalies that deviate significantly from normal behavior.</li>
    </ul>

    
    <!--------------------------->
    <h4 id="pros">Pros</h4>
    <ol>
        <li><strong>Effective in High-Dimensional Spaces:</strong> SVMs perform well in high-dimensional spaces, making them suitable for tasks involving a large number of features, such as image classification and text categorization.</li>

        <li><strong>Robust to Overfitting:</strong> SVMs are less prone to overfitting compared to other algorithms like decision trees. By maximizing the margin between classes, SVMs generalize well to unseen data.</li>
        
        <li><strong>Versatile Kernel Functions:</strong> SVMs can handle non-linear decision boundaries using various kernel functions (e.g., polynomial, radial basis function), allowing them to capture complex relationships in the data.</li>
        
        <li><strong>Works Well with Small Datasets:</strong> SVMs can perform well even with relatively small datasets, as they focus on the points closest to the decision boundary (support vectors) rather than the entire dataset.</li>
        
        <li><strong>Global Optimization:</strong> SVMs use convex optimization techniques to find the optimal hyperplane, ensuring that the solution is globally optimal and not affected by local minima.</li>
        
        <li><strong>Regularization Parameter:</strong> SVMs offer a regularization parameter (C) that allows users to control the trade-off between maximizing the margin and minimizing classification errors, providing flexibility in model tuning.</li>
    </ol>

    <!--------------------------->
    <h4 id="cons">Cons</h4>
    <ol>
        <li><strong>Sensitivity to Parameter Tuning:</strong> SVMs require careful selection of parameters, such as the choice of kernel function and regularization parameter. Improper parameter tuning can lead to suboptimal performance.</li>

        <li><strong>Computationally Intensive:</strong> Training an SVM can be computationally intensive, especially for large datasets. The training time and memory requirements increase significantly with the number of data points.</li>
        
        <li><strong>Limited Interpretability:</strong> The decision boundary produced by SVMs may be difficult to interpret, particularly when using complex kernel functions or in high-dimensional spaces. This limits the insight into the underlying relationships in the data.</li>
        
        <li><strong>Memory Usage:</strong> SVMs require storing all support vectors in memory, which can become impractical for very large datasets with numerous support vectors, leading to high memory usage.</li>
        
        <li><strong>Binary Classification:</strong> SVMs are inherently binary classifiers and need additional techniques (e.g., one-vs-all) to handle multi-class classification problems, which can increase complexity.</li>
        
        <li><strong>Sensitive to Noise:</strong> SVMs can be sensitive to noise in the training data, as outliers or mislabeled points near the decision boundary may significantly affect the model's performance.</li>
    </ol>

    <!--------------------------------->
    <h2 id="math-svm">Mathematical intuition behind the Support Vector Machine</h2>
    <h4 id="explanation-1">Support-vector-machine explanation: 2D</h4>
    <p>Imagine you have a scatter plot where the green points represent one class and the orange points represent another class. To separate these two classes, an SVM seeks to find the best-fitting line or plane (hyperplane) that maximizes the margin between the two classes. <strong><em>We can find the best line by computing the maximum margin from equidistant support vectors</em></strong>.</p>
    <figure>
        <img src="assets/img/machine-ln/support-vector-machine.png" alt="" style="max-width: 80%; max-height: auto;">
        <figcaption style="text-align: center;">Support vectors in circle (<strong>Image credit:</strong> &#169; <a href="index.html">@arunp77</a>)</figcaption>
    </figure>
    <p>Let's understand it in detail. We want to classify that the new data point as either green or orange. To classify these points, we can have many decision boundaries, but the question is which is the best and how do we find it? The best hyperplane is that plane that has the maximum distance from both the classes, and this is the main aim of SVM. This is done by finding different hyperplanes which classify the labels in the best way then it will choose the one which is farthest from the data points or the one which has a maximum margin.</p>
    <figure>
        <img src="assets/img/machine-ln/support-vector-machine1.png" alt="" style="max-width: 80%; max-height: auto;">
        <figcaption style="text-align: center;"> (<strong>Image credit:</strong> &#169; <a href="index.html">@arunp77</a>)</figcaption>
    </figure>
    <p>Let's understand first what is dot product of vectors. The dot product can be defined as the projection of one vector along with another, multiply by the product of another vector and is defined as \(\vec{A} \cdot \vec{B} = |A| \cos \theta |B| \), where \(|A| \cos \theta\) is the projection of \(\vec{A}\) on \(\vec{B}\). In SVM, we just need the projection of \(\vec{A}\) not the magnitude of \(\vec{B}\). Instead we take \(\vec{A} \cdot \vec{B} = |A| \cos \theta \times ~(\text{unit vector of } \vec{B})\) as to get the projection, we can just take the unit vector of \(\vec{B}\) because it will be in the direction of \(\vec{B}\) but its magnitude will be 1. Now let's consider image (b) in the above figure where we consider a random data point in black and corresponding vector \(\vec{X}\). We aim to determine if a point lies to the right (positive) or left (negative) side of the separating line (plane). This is done by computing the dot product of the vector onto the perpendicular line to the boundary separating the two sets of data points (green and orange). Here \(c\) is the distance of the light blue separing line from the origin. Now following three conditions may arise:</p>
    \begin{align*}
    & \vec{X} \cdot \vec{w} = c \quad && \text{(the point lies on the decision boundary)} \\
    & \vec{X} \cdot \vec{w} > c \quad && \text{(positive samples)} \\
    & \vec{X} \cdot \vec{w} < c \quad && \text{(negative samples)}
    \end{align*}
    <p>Here the dot product of the two vectors (where \(\vec{w}\) is a unit vector perpendicular to the decision boundary), gives the distance of vector X from the decision boundary and there may be infinte points on the boundary to measure the distance from. We simply take perpendicular and use it as a reference and then take projections of all the other data points on this perpendicular vector and then compare the distance. In SVM we also have a concept of margin. We can rewrite the equation \(\vec{X} \cdot \vec{w} -c \geq 0 \Rightarrow  \vec{X} \cdot \vec{w} +b \geq 0 \), where we just replaced \(-c\) with the \(b\). </p>
    <div class="grey-box">
        &#128073; In general equation of a plane can be written as \(\vec{n} \cdot \vec{r} = \vec{n} \cdot \vec{r}_0\), where we can write \(\vec{n}  = (A, B, C)\) which is the normal vector to the plane, \(\vec{r}\) is the  position vector of any point \((x,y,z)\) on the plane, and \(\vec{r}_0\) is the position vector of a known point \((x_0, y_0, z_0)\) on the plane.</div>
    <p>Therefore, we have</p>

    \begin{equation}
        y =
        \begin{cases}
            +1 & \text{if}~ \vec{X}\cdot \vec{w} +b \geq 0  \\
            -1 & \text{if } \vec{X}\cdot \vec{w} +b < 0
        \end{cases}
    \end{equation}
    <p>If the value of \(\vec{X}\cdot \vec{w} +b>0\) then we can say it is a positive point otherwise it is a negative point. Now we need \((w,b)\) such that the margin has a maximum distance. Let’s say this distance is '\(d\)'. To calculate \(d\), we need the equation of the two lines L1, and L2. We want our plane to have equal distance from both the classes that means L should pass through the center of L1 and L2 that’s why we take magnitude equal. For mathematical convience, we consider the equations of the two lines \(\vec{X}\cdot \vec{w} +b =1\) and \(\vec{X}\cdot \vec{w} +b = -1\). Another reason, why choose 1, is if we multiply the equation of hyperplane with a factor greater than 1 then the parallel lines will shrink and if we multiply with a factor less than 1, they expand. We can now say that these lines will move as we do changes in \((w,b)\) and this is how this gets optimized. But what is the optimization function? Let’s calculate it. We know that the aim of SVM is to maximize this margin that means distance \((d)\). But there are few constraints for this distance \((d)\). Let’s look at what these constraints are.</p>
    
    <h5><strong>Optimization function and its constrainsts</strong></h5>
    <ol>
        <li><strong>Hard Margin SVM:</strong> Since, for orange points \(\vec{w}\cdot \vec{X} +b \leq -1\) and for green points \(\vec{w}\cdot \vec{X} +b \geq 1\) i.e. negative classes have \(y = -1\) and positive classes have \(y = 1\). We can say that for everypoint to be correctly classfied, above two condition can be combined as:
            $$y_i(\vec{w}\cdot \vec{X}+b)\geq 1$$
            <ul>
                <li>Suppose a green point is correctly classfied that means it will follow \(\vec{X}\cdot \vec{w} +b >=1\), if we multiply this with \(y=1\) we get this same equation mentioned above.</li>
                <li>Similarly, if we do this with a orange point with \(y=-1\) we will again get this equation. Hence, we can say that we need to maximize (d) such that this constraint holds true.</li>
            </ul>
            
            <div style="display: flex; align-items: center;">
                <div style="flex: 1;">
                    <figure>
                        <img src="assets/img/machine-ln/support-vector-machine2.png" alt="" style="max-width: 70%; max-height: auto;">
                        <figcaption style="text-align: center;">(<strong>Image credit:</strong> &#169; <a href="index.html">@arunp77</a>)</figcaption>
                    </figure>
                </div>
                <div style="flex: 1;">
                    <p style="padding-left: 20px;">Now we can consider two support vectors, one from negative class and second from the positive class. The distance between the two vectors \(\vec{X}_1\) and \(\vec{X}_2\) will be \(\vec{X}_2 - \vec{X}_1\). What we need is, the shortest distance between these two points which can be found using a trick we used in the dot product. We take a vector \(\vec{w}\) perpendicular to the hyperplane and then find the projection of \(\vec{X}_2\) will be \(\vec{X}_2 - \vec{X}_1\) vector on \(\vec{w}\), where \(\vec{w}\) is the unit vector.  Therefore the projection of avector on another vector is:
                    $$(\vec{X}_2 -\vec{X}_1)\cdot \frac{\vec{w}}{\|\vec{w}\|} \Rightarrow \frac{\vec{X}_2 \cdot \vec{w} -\vec{X}_1 \cdot \vec{w} }{\|\vec{w}\|}.$$
                    Since the two vectors \(X_2\) and \(X_1\) are support vectors and they lie on the hyperplane, we can write: \(y_i (\vec{w}\cdot \vec{X}+b) = 1\), i.e \(1\times (\vec{w}\cdot \vec{X}+b) = 1 \Rightarrow \vec{w}\cdot \vec{X}_1 =1- b\) for positive point (\(y=1\)) and \(-1 \times (\vec{w}\cdot \vec{X}+b) = 1 \Rightarrow \vec{w}\cdot \vec{X}_1 = - 1- b\). Yherefore, substituing the two value in above equations:
                    $$\frac{\vec{X}_2 \cdot \vec{w} -\vec{X}_1 \cdot \vec{w} }{\|\vec{w}\|} = \frac{(1-b) - (-1-b)}{\|\vec{w}\|} =\frac{2}{\|\vec{w}\|} = d.$$
                    </p>
                </div>
            </div>
            <p>Hence the equation which we have to maximize  in the context of finding the maximum margin separating hyperplane is:</p>

            $$\text{argmax}_{(\vec{w}^*, b^*)} \left(\frac{2}{\|\vec{w}\|}\right) \Rightarrow \text{such that} ~~~ y_i \left( \vec{w}\cdot \vec{X}+b\right)\geq 1.$$
            
            <p>This type of SVM is known as <strong>Hard Margin SVM</strong>. It is to be noted that, in reality there is hardly any case we get perfectly linearly separable data and hence we fail to use this condition we proved here.</p>
        </li>
        
        <li><strong>Soft Margin SVM:</strong> In a traditional SVM, we aim to find a hyperplane that separates the data into two classes with the largest margin possible. However, in real-world scenarios, the data might not be linearly separable, or there could be outliers that affect the decision boundary. The Soft Margin SVM addresses these issues by allowing for some misclassifications and incorporating a penalty term for them. Mathematically, let's start with the optimization problem for the Soft Margin SVM. Given training data \((x_1, y_1),(x_2, y_2), (x_n, y_n)\), where \(x_i \in \mathbb{R}^d\) is the input feature vector and \(y_i \in \{-1, 1\}\) is the corresponding class label, the Soft Margin SVM aims to find the hyperplane represented by \(\mathbf{w} \cdot \mathbf{x} + b = 0\) that maximizes the margin while allowing for some misclassifications.
            <div class="grey-box">
                <strong>&#128204; Note:</strong> Here it is to be noted here that we took argmin instead of argmax compared to the Hard Margin SVM. We know that \(\text{max}[f(x)]\) can also be written as \(\min[1/f(x)]\), it is common practice to minimize a cost function for optimization problems; therefore, we can invert the function <strong>argmax</strong> function to <strong>argmin</strong>.
            </div>

            \[
            \text{argmin}_{\mathbf{w}, b, \boldsymbol{\xi}} \left( \frac{1}{2}||\mathbf{w}||^2 + C\sum_{i=1}^{n} \xi_i \right)
            \]
        <p>subject to the constrainsts:</p>
        $$y_i(\mathbf{w} \cdot \mathbf{x}_i + b) \geq 1 - \xi_i \quad \text{and} \quad \xi_i \geq 0, \quad \forall i.$$

        <ul>
            <li>Here, \(C > 0\) is the regularization parameter that controls the trade-off between maximizing the margin and minimizing the classification errors. A larger \(C\) value penalizes misclassifications more heavily, leading to a narrower margin but potentially better classification accuracy. It is a hyperparameter and we find the optimal value of \(C\) using <code>GridsearchCV</code> and cross-validation.</li>

            <li>The term \(\frac{1}{2}||\mathbf{w}||^2\) represents the margin maximization objective, aiming to maximize the margin between the support vectors (data points closest to the decision boundary) of different classes.</li>
    
            <li>The term \(C\sum_{i=1}^{n} \xi_i\) serves as the regularization term, penalizing misclassifications. By minimizing this term, we encourage the SVM to find a balance between maximizing the margin and minimizing classification errors.</li>
        </ul>

        <p>In summary, the Soft Margin SVM introduces slack variables to handle misclassifications and incorporates a regularization parameter to control the trade-off between margin maximization and error minimization. This approach allows the SVM to generalize better to real-world datasets with noise or non-linearly separable classes.</p>
        </li>   
    </ol>
    
    <p>So in summary when using an SVM to classify data points into different classes:</p>
    <ul>
        <li>Support vectors are chosen as the data points closest to the separating hyperplane.</li>
        <li>The margin, or the distance between the support vectors and the hyperplane, is maximized to ensure robust classification.</li>
        <li>Each data point's influence on determining the hyperplane's position is weighted based on its proximity to the hyperplane.</li>
    </ul>

    <!--------------------------------------->
    <h4 id="explanantion-2">Classification problem with higher dimension data</h4>
    <p>The data set shown below in Image-(a) has no clear linear separation between the two classes. In machine learning parlance, we would say that these are not linearly separable. How can we get the support vector machine to work on such data? </p>
    <figure>
        <img src="assets/img/machine-ln/support-vector-machine-3D.png" alt="" style="max-width: 80%; max-height: auto;">
        <figcaption style="text-align: center;">Support vectors in circle (<strong>Image credit:</strong> &#169; <a href="index.html">@arunp77</a> )</figcaption>
    </figure>
    <p>Since we can't separate it into two classes using a line, we need to transform it into a higher dimension by employing a kernel function to the data set. A higher dimension enables us to clearly separate the two groups with a plane. Here, we can draw some planes between the green dots and the orange dots — with the end goal of maximizing the margin. If we let R=the number of dimensions, the kernel function will convert a two-dimensional space (R2) to a three-dimensional space (R3). Once the data is separated into three dimensions, we can apply SVM and separate the two groups using a two-dimensional plane. For a higher dimension, we would have to use higher diemntsional curve. </p>

    <!--------------------->
    <h3 id="kernel-fun">Kernel Functions</h3> 
    <p>Kernel functions play a fundamental role in Support Vector Machines (SVMs), enabling them to handle non-linear relationships between features and find complex decision boundaries. Let's delve into a detailed explanation of kernel functions: </p>

    <!------------------->
    <h4 id="purpose-kernel">Purpose of Kernel Functions</h4>
    <p>Kernel functions are mathematical transformations applied to input data in SVMs. Their primary purpose is to map the original input space into a higher-dimensional feature space, where the classes may be more easily separable by a hyperplane. By transforming the data into a higher-dimensional space, kernel functions enable SVMs to capture non-linear relationships and complex patterns in the data. A kernel function, denoted as \(K(\textbf{x}, \textbf{x}')\), takes two input vectors \(\textbf{x}\) and \(\textbf{x}'\) and computes a measure of similarity or distance between them. This measure is often represented as the dot product of the transformed feature vectors in the higher-dimensional space.</p>  
    
    
    <h4 id="types-kernel"><a href="https://www.cs.cornell.edu/courses/cs4780/2017sp/lectures/lecturenote13.html" target="_blank">Types of Kernel Functions</a></h4>
    <p>There are several types of kernel functions commonly used in SVMs. For the input vectors \(\textbf{x}\) and \(\textbf{x}'\):</p>
    <div class="grey-box"> &#x270D; <strong>Book suggestion:</strong> The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Trevor Hastie, Robert Tibshirani, Jerome H. Friedman </div>
    <ol>
        <li><strong><u><a href="https://www.cs.cornell.edu/courses/cs4780/2017sp/lectures/lecturenote09.html" target="_blank">Linear Kernel</a></u> \(K_{\text{linear}}(\textbf{x},\textbf{x}')\):</strong> This is the simplest kernel function, where the dot product of the input vectors is computed directly in the original feature space. It is suitable for linearly separable data.
        $$K_{\text{linear}}(\textbf{x}, \textbf{x}') = \textbf{x}^T \textbf{x}'$$
        here \(\textbf{x}^T\) represents the transpose of vector \(\textbf{x}\), and \(\textbf{x}'\) is another vector.
        <ul>
            <li><strong>Interpretation:</strong> The linear kernel measures the similarity between two vectors by taking into account the alignment of their features. It computes the weighted sum of the products of corresponding features in the input vectors.</li>
            <li><strong>Features:</strong> In the original feature space, each input vector \(\textbf{x}\) is represented by a set of features. The dot product \(\textbf{x}^T \textbf{x}'\) calculates the sum of the products of corresponding features in vector \(\textbf{x}\) and \(\textbf{x}'\), effectively measuring their similalrity.</li>
            <li><strong>Linear Separation:</strong> The linear kernel is suitable for linearly separable data, where a straight line (or hyperplane in higher dimensions) can effectively separate the classes. It works well when the decision boundary between classes can be represented by a linear equation.</li>
            <li><strong>Advantages: </strong>
            <ul>
                <li><strong>Simplicity:</strong> The linear kernel is straightforward and computationally efficient.</li>
                <li><strong>Interpretability:</strong> The decision boundary learned by SVM with a linear kernel can be easily interpreted as a linear combination of input features.</li>
            </ul>
            </li>
            <li><strong>Limitations: </strong>
            <ul>
                <li><strong>Limited Complexity:</strong> The linear kernel may not capture complex relationships between features and classes, making it less suitable for datasets with non-linear separability.</li>
                <li><strong>Performance on Non-linear Data:</strong> In cases where the data is not linearly separable, the linear kernel may lead to suboptimal classification performance.</li>
            </ul>
            </li>
            <li><strong>Applications:</strong>
            <ul>
                <li><strong>Text Classification:</strong> Linear kernels are commonly used in text classification tasks where the feature space is often high-dimensional.</li>
                <li><strong>Linear Regression:</strong> Linear kernels can be applied in linear regression problems to model relationships between input features and target variables.</li>
            </ul>
            </li>
            <li><strong>Example:</strong>Let's consider a simple example with two input vectors \(\textbf{x}\) and \(\textbf{x}'\) represented by two-dimensional feature vectors. The linear kernel computes the dot product of these vectors directly in the original feature space. Suppose we have two input vectors
            $$x = \begin{pmatrix} x_1 \\ x_2 \end{pmatrix}$$
            and 
            $$x' = \begin{pmatrix} x'_1 \\ x'_2 \end{pmatrix}$$
            <p>The linear Kernel between the two vectors is computed as:</p>
            $$K_{\text{linear}}(\textbf{x}, \textbf{x}') = \textbf{x}^T \textbf{x} =\begin{pmatrix} x_1 & x_2 \end{pmatrix} \begin{pmatrix} x'_1 \\ x'_2 \end{pmatrix} = x_1 x_1'+x_2 x_2'$$
            This equation represents the similarity between the two input vectors \(\textbf{x}\) and \(\textbf{x}'\) based on the alignment of their features. The larger the value of the Kernel \(K_{\text{linear}}(\textbf{x}, \textbf{x}')\), the more similar the vectors \(\textbf{x}\) and \(\textbf{x}'\) are considered to be. For example two vectors:
            $$x = \begin{pmatrix} 2 \\ 3 \end{pmatrix}$$
            and 
            $$x' = \begin{pmatrix} 4 \\ 1 \end{pmatrix}$$
            Kernel \(K_{\text{linear}}(\textbf{x}, \textbf{x}') = 11\) indicating a relatively high similalrity between the two inputs vectors. 
            </li>
        </ul>
        </li>
        <li><strong><u><a href="https://www.cs.cornell.edu/courses/cs4780/2017sp/lectures/lecturenote14.html" target="_blank">Polynomial Kernel</a></u> \(K_{\text{poly}}(\textbf{x},\textbf{x}')\):</strong>
            The Polynomial Kernel is a type of kernel function used in Support Vector Machines (SVMs) to handle non-linear relationships between features. It transforms the input data into a higher-dimensional space, where it may be easier to find a separating hyperplane. The polynomial kernel raises the dot product of the input vectors to a certain power \(d\), allowing SVMs to capture polynomial decision boundaries. It is defined as
        $$K_{\text{poly}}(\textbf{x},\textbf{x}') = \left(\textbf{x}\cdot \textbf{x}'+c\right)^d,$$
        where \(c\) is a constant and \(d\) is the degree of the polynomial.
        <ul>
            <li><strong>Role of Parameters: </strong>
                <ul>
                    <li><strong>Degree \((d)\):</strong> The degree parameter determines the degree of the polynomial transformation applied to the input data. Higher values of \(d\) result in more complex decision boundaries.</li> 
                    <li><strong>Constant \((c)\):</strong>The constant term acts as a bias and helps control the influence of lower-degree polynomials. It shifts the decision boundary away from the origin in the feature space.</li>         
                </ul>
            </li> 
            <li><strong>Kernel Properties:</strong>
                <ul>
                    <li><strong>Linearity: </strong>Despite its name, the Polynomial Kernel is capable of capturing non-linear relationships between features. By raising the dot product of the input vectors to a higher power, the kernel can represent complex decision boundaries.</li> 
                    <li><strong>Computational Complexity: </strong>The computational complexity of the Polynomial Kernel depends on the degree parameter \(d\). Higher values of \(d\) increase the computational cost, as they require computing higher-order polynomials. </li>         
                </ul>
            </li> 
            <li><strong>Choice of Parameters: </strong>
                <ul>
                    <li><strong>Degree \((d)\): </strong>The degree parameter should be chosen based on the complexity of the data and the desired level of model flexibility. Higher values of \(d\) may lead to overfitting if the data is not complex enough to warrant such a high-degree polynomial.</li> 
                    <li><strong>Constant Term \((c)\): </strong> The constant term \(c\) can be set empirically or through cross-validation. It helps adjust the bias of the model and fine-tune the decision boundary.</li>
                </ul>
            </li> 
            <li><strong>Example Application:</strong> The Polynomial Kernel is commonly used in SVMs for tasks such as image classification, text classification, and pattern recognition. It is effective in capturing non-linear relationships between features and constructing complex decision boundaries in high-dimensional feature spaces. </li>
        </ul>
        <p>In summary, the Polynomial Kernel is a versatile kernel function that allows SVMs to handle non-linear relationships between features by transforming the input data into a higher-dimensional space. It offers flexibility in capturing complex patterns and can be customized through parameters like degree and constant term to suit the characteristics of the data.</p>
        </li>
        <li><strong><u><a href="https://www.cs.cornell.edu/courses/cs4780/2017sp/lectures/lecturenote15.html" target="_blank">Radial Basis Function (RBF) Kernel</a></u> \(K_{\text{RBF}}(\textbf{x}, \textbf{x}')\):</strong> The Radial Basis Function (RBF) kernel, also known as the Gaussian kernel, is a popular choice in Support Vector Machines (SVMs) for its ability to capture complex non-linear relationships between data points. The RBF kernel computes the similarity between two input vectors \(\textbf{x}\) and \(\textbf{x}'\) based on the Euclidean distance between them in the input space. Mathematically, the RBF kernel is defined as:
            $$K_{\text{RBF}}(\textbf{x}, \textbf{x}') = \exp\left(-\gamma \|\textbf{x} - \textbf{x}'\|^2\right)$$
            <p>Here, \(\gamma>0\) is a parameter controlling the kernel's width, and \(\|\textbf{x}-\textbf{x}'\|\) represents the Euclidean distance between vectors \(\textbf{x}\) and \(\textbf{x}'\).</p>
            <ul>
                <li><strong>Interpretation: </strong>
                    <ul>
                        <li>The RBF kernel measures the similarity or closeness between two data points based on their distance in the input space.</li>
                        <li>When \(\textbf{x}\) and \(\textbf{x}'\) are close to each other, their Euclidean distance  \(\|\textbf{x}-\textbf{x}'\|\) is small, resulting in a high similalrity value.</li>
                        <li>Conversely, when \(\textbf{x}\) and \(\textbf{x}'\) are far apart, their distance increases, leading to a lower similalrity value. </li>
                        <li>The paramter \(\gamma\) controls the kernel's width, determing how quickly the similalrity decays as the distance between points increases. A smaller \(\gamma\) results in a broder kernel, capturing more global relationships. while a larger \(\gamma\) focuses on local relationships.</li>
                    </ul>
                </li>
                <li><strong>Effect on SVM Decision Boundary:</strong>
                    <ul>
                        <li>In SVMs, the RBF kernel allows for the construction of non-linear decision boundaries that can adapt to complex data distributions.</li>
                        <li>By mapping the input data into a higher-dimensional feature space implicitly, the RBF kernel transforms the data in a way that enables SVMs to find optimal separating hyperplanes even for non-linearly separable data.</li>
                    </ul>
                </li>
                <li><strong>Choice of \(\gamma\):</strong>
                    <ul>
                        <li>The choice of the \(\gamma\) parameter is critical in determining the behavior of the RBF kernel.</li>
                        <li>A smaller \(\gamma\) value results in a smoother decision boundary, capturing broader patterns in the data but potentially leading to underfitting.</li>
                        <li>Conversely, a larger \(\gamma\) value creates a more complex decision boundary, capturing finer details in the data but increasing the risk of overfitting.</li>
                    </ul>
                </li>
                <li><strong>Application: </strong>
                    <ul>
                        <li>The RBF kernel is widely used in SVMs for various classification tasks, including image recognition, text classification, and bioinformatics.</li>
                        <li>Its flexibility in capturing non-linear relationships makes it suitable for datasets with complex structures and intricate patterns.</li>
                    </ul>
                </li>
            </ul>
            <p>In summary, the Radial Basis Function (RBF) kernel is a powerful tool in SVMs for capturing non-linear relationships between data points. Its ability to adapt to complex data distributions and construct flexible decision boundaries makes it a popular choice for a wide range of classification tasks.</p>
        </li>
        <li><strong><u>Sigmoid Kernel</u>:</strong> The sigmoid kernel computes the similarity between two vectors using the hyperbolic tangent function:
        $$K_{\text{sigmoid}}(\textbf{x}, \textbf{x}') = \text{tanh}\left(\alpha x^T x' +\beta\right)$$
        In this equation, \(\alpha\) and \(\beta\) are parameters.
        </li>
        <li><strong><u>Kernel Trick</u>:</strong> The kernel trick is a computational shortcut that allows SVMs to implicitly compute the dot product between feature vectors in the higher-dimensional space without explicitly calculating the transformation. This is achieved by expressing the optimization problem in terms of kernel functions, avoiding the need to compute the transformation explicitly.</li>
        <li><strong>Bessel Function Kernel:</strong> The Bessel function kernel is a type of radial basis function (RBF) kernel, similar to the Gaussian RBF kernel. It is defined using the Bessel function of the first kind. The Bessel function kernel can be defined as:
        $$K(x, x') = J_v(\gamma \|x-x'\|)$$
        where:
        <ul>
            <li>\(x\) and \(x'\) are the input data points,</li>
            <li>\(J_v\) is the Bessel function of the first kind,</li>
            <li>\(\gamma\) is a scaling parameter, and</li>
            <li>\(v\) is the order of the Bessel function.</li>
        </ul>
        <p>The Bessel function kernel measures similarity between data points based on their distance in the input space. It is particularly useful when dealing with periodic or oscillating data patterns.</p>
        </li>
        <li><strong>ANOVA Kernel Function: </strong>The ANOVA kernel, short for analysis of variance kernel, is used for capturing interactions between multiple input dimensions. It is defined as the sum of all possible interactions between subsets of dimensions. The ANOVA kernel function can be defined as: 
        $$K(x, x') = \sum_{d=1}^{D} \sum_{I \in \mathcal{P}(d)} \prod_{i \in I} k_i(x_i, x_i')$$
        <ul>
            <li>\(x\) and \(x'\) are the input data points,</li>
            <li>\(D\) is the total number of dimensions (features) in the input space,</li>
            <li>\(\mathcal{P}(d)\) denotes the power set of dimensions of size \(d\)</li>
            <li>\(I\) represents a subset of dimensions of size \(d\)</li>
            <li>\(k_i\) is a kernel function operating on the \(i-\)th dimesnion,</li>
            <li>The outer sum ranges over all dimensions, and</li>
            <li>The inner sum ranges over all subsets of dimensions of size \(d\).</li>
        </ul>
        The ANOVA kernel captures both additive and interaction effects between input dimensions. It is particularly useful when dealing with high-dimensional data where interactions between subsets of dimensions are important for prediction.
        </li>
    </ol>

    <!-------------------------->
    <h4 id="steps-to-SVM">Step-by-step guide to performing Support Vector Machine (SVM)</h4>
    <ol>
        <li><strong>Define Problem:</strong> Clearly understand the task at hand.</li>
        <li><strong>Data Prep:</strong> Collect and preprocess the dataset.</li>
        <li><strong>Select Kernel:</strong> Choose a kernel function (linear, polynomial, RBF).</li>
        <li><strong>Parameter Tuning:</strong> Optimize hyperparameters (C, gamma) via cross-validation.</li>
        <li><strong>Model Training:</strong> Train SVM on the prepared dataset.</li>
        <li><strong>Evaluate:</strong> Assess model performance using relevant metrics.</li>
        <li><strong>Refinement (Optional):</strong> Fine-tune hyperparameters or perform feature engineering.</li>
        <li><strong>Deployment:</strong> Deploy the model for predictions.</li>
        <li><strong>Maintenance:</strong> Monitor and update the model as needed.</li>
    </ol>

    <!-------------------------->
    <h3 id="example-python">Example project</h3>
    <p>For the current project, we choose iris datasets provided by <code>skelarn.datasets</code>.</p>
    Let's follow following steps:
    <ul>
        <li><strong>Step-1:</strong> Load the datasets and create a dataframe with both the features and target variable
            <pre><code class="language-python">
                import pandas as pd
                import numpy as np
                import matplotlib.pyplot as plt
                from sklearn import svm
                from sklearn.datasets import load_iris
                
                # Load the Iris dataset
                iris = load_iris()
                
                # Convert the dataset to a DataFrame
                iris_df = pd.DataFrame(data=iris.data, columns=iris.feature_names)
                
                # Add the target variable (species) to the DataFrame
                iris_df['species'] = iris.target
                
                # Replace target values with actual species names
                iris_df['species'] = iris_df['species'].map({0: 'setosa', 1: 'versicolor', 2: 'virginica'})
                
                # Display the DataFrame
                iris_df
            </code></pre>
            <figure>
                <img src="assets/img/machine-ln/support-vector-irisdata.png" alt="" style="max-width: 90%; max-height: auto;">
                <figcaption style="text-align: center;"></figcaption>
            </figure>
        </li>
        <li><strong>Step-2</strong> Creating the features and target data:
            <pre><code class="language-python">
                # creating the Features and target data
                # Features (input data)
                X = iris.data
                
                # Target variable (output labels)
                y = iris.target
            </code></pre>
        </li>
        <li><strong>Step-3:</strong> Now just slecting just first two columns and plotting them using scatter plot:
            <pre><code class="language-python">
            # Create features and target data
            X = iris.data[:, :2]  # Considering only the first two features for visualization
            y = iris.target
            
            # Plotting
            x_min, x_max = X[:, 0].min() - 1, X[:, 0].max() + 1 # +/- are added for padding purpose. 
            y_min, y_max = X[:, 1].min() - 1, X[:, 1].max() + 1 # +/- are added for padding purpose. 
            
            # step size (h) for the meshgrid
            h = (x_max / x_min) / 100 # used to create a fine grid of points for visualization.
            
            # Creating a meshgrid of points
            xx, yy = np.meshgrid(np.arange(x_min, x_max, h), np.arange(y_min, y_max, h))
            # Flattening the meshgrid points into a single array
            X_plot = np.c_[xx.ravel(), yy.ravel()]
            
            # Visualize the plot
            plt.figure(figsize=(10, 8))
            
            # Plot the training points
            plt.scatter(X[:, 0], X[:, 1], c=y, cmap='RdYlBu', edgecolor='k')
            '''
            Here 
                - c = This parameter specifies the color of each point in the scatter plot 
                based on the values of the target variable y
            '''
            
            plt.xlim(xx.min(), xx.max())
            plt.ylim(yy.min(), yy.max())
            plt.title("Iris Dataset")
            plt.xlabel("Sepal length")
            plt.ylabel("Sepal width")
            plt.show()
            </code></pre>
            <figure>
                <img src="assets/img/machine-ln/support-vector-iris-scatter.png" alt="" style="max-width: 50%; max-height: auto;">
                <figcaption style="text-align: center;"></figcaption>
            </figure>
        </li>
        <li><strong>Step-4</strong> Using Kernels and classiying the data:
            <pre><code class="language-python">
                from sklearn.svm import SVC
                from sklearn.model_selection import train_test_split
                from sklearn.metrics import accuracy_score
                
                # Assuming X_train, X_test, y_train, y_test are already defined
                
                # Create an instance of the SVM classifier
                svm_classifier = SVC(kernel='linear', C=1.0)
                
                # Train the SVM classifier
                svm_classifier.fit(X_train, y_train)
                
                # Predict the labels for the test data
                y_pred = svm_classifier.predict(X_test)
                
                # Evaluate the performance of the classifier
                accuracy = accuracy_score(y_test, y_pred)
                print("Accuracy:", accuracy)
                # Plot decision boundaries
                Z = svm_classifier.predict(np.c_[xx.ravel(), yy.ravel()])
                Z = Z.reshape(xx.shape)
                plt.contourf(xx, yy, Z, alpha=0.8)
                
                # Plot data points with different classes shaded or colored
                plt.scatter(X[:, 0], X[:, 1], c=y, cmap=plt.cm.Paired, edgecolors='k')
                plt.xlabel('Sepal length')
                plt.ylabel('Sepal width')
                plt.title('SVM Decision Boundaries')
                plt.show()
            </code></pre>
            <pre>Accuracy: 0.9</pre>
            <figure>
                <img src="assets/img/machine-ln/support-vector-decision-boundary.png" alt="" style="max-width: 50%; max-height: auto;">
                <figcaption style="text-align: center;"></figcaption>
            </figure>
            For other kernels such as <strong>Sigmoid Kernel Implementation</strong>, <strong>RBF Kernel Implementation</strong>, and <strong>Polynomial Kernel Implementation</strong>, please visit <a href="https://github.com/arunp77/Machine-Learning/tree/main" target="_blank">my github repo</a> and <a href="https://github.com/arunp77/Machine-Learning/blob/main/Supervised-learning/Project-2.5-Support%20vector.ipynb" target>Juoyter notebook</a>.
        </li>
    </ul>
    <p>On my repo, a detailed analysis of each kernel implememntation and how to choose a kernel is discussed.</p>

    </section>

    <!----------- Reference ----------->
    <section id="reference">
    <h2>References</h2>
    <ul>
        <li><a href="https://arunp77.github.io/logistic-regression.html#con-mat" target="_blank">Confusion matrix details</a>.</li>
        <li>My github Repositories on <a href="https://github.com/arunp77/Machine-Learning/" target="_blank">Machine learning</a></li>
        <li><a href="https://courses.cis.cornell.edu/cs4780/2017sp/" target="_blank">Course notes on Machine learning algorithms</a>.</li>
        <li><a href="https://mlu-explain.github.io/linear-regression/" target="_blank">A Visual Introduction To Linear regression</a> (Best reference for theory and visualization).</li>
        <li>Book on Regression model: <a href="https://avehtari.github.io/ROS-Examples/" target="_blank">Regression and Other Stories</a></li>
        <li>Book on Statistics: <a href="https://hastie.su.domains/Papers/ESLII.pdf" target="_blank">The Elements of Statistical Learning</a></li>
        <li><a href="https://www.javatpoint.com/machine-learning-naive-bayes-classifier" target="_blank">Naïve Bayes Classifier Algorithm, JAVAPoint.com</a></li>
        <li><a href="https://www.colorado.edu/amath/sites/default/files/attached-files/ch12_0.pdf">https://www.colorado.edu/amath/sites/default/files/attached-files/ch12_0.pdf</a></li>
        <li><a href="https://datahacker.rs/002-machine-learning-linear-regression-model/" target="_blank">One of the best description on Linear regression</a>.</li>
    </ul>
    </section>

    <hr>
    
    <div style="background-color: #f0f0f0; padding: 15px; border-radius: 5px;">

    <h3>Some other interesting things to know:</h3>
    <ul style="list-style-type: disc; margin-left: 30px;">
        <li>Visit my website on <a href="sql-project.html">For Data, Big Data, Data-modeling, Datawarehouse, SQL, cloud-compute.</a></li>
        <li>Visit my website on <a href="Data-engineering.html">Data engineering</a></li>
    </ul>
    </div>
    <p></p>

    <div class="navigation">
        <a href="index.html#portfolio" class="clickable-box">
            <span class="arrow-left">Portfolio section</span>
        </a>
        
        <a href="machine-learning.html" class="clickable-box">
            <span class="arrow-right">Content</span>
        </a>
    </div>
</div>
</div>
</section><!-- End Portfolio Details Section -->
</main><!-- End #main --

<!-- ======= Footer ======= -->
<footer id="footer">
  <div class="container">
    <div class="copyright">
      &copy; Copyright <strong><span>Arun</span></strong>
    </div>
  </div>
</footer><!-- End  Footer -->

<a href="#" class="back-to-top d-flex align-items-center justify-content-center"><i class="bi bi-arrow-up-short"></i></a>

<!-- Vendor JS Files -->
<script src="assets/vendor/purecounter/purecounter_vanilla.js"></script>
<script src="assets/vendor/aos/aos.js"></script>
<script src="assets/vendor/bootstrap/js/bootstrap.bundle.min.js"></script>
<script src="assets/vendor/glightbox/js/glightbox.min.js"></script>
<script src="assets/vendor/isotope-layout/isotope.pkgd.min.js"></script>
<script src="assets/vendor/swiper/swiper-bundle.min.js"></script>
<script src="assets/vendor/typed.js/typed.umd.js"></script>
<script src="assets/vendor/waypoints/noframework.waypoints.js"></script>
<script src="assets/vendor/php-email-form/validate.js"></script>

<!-- Template Main JS File -->
<script src="assets/js/main.js"></script>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    hljs.initHighlightingOnLoad();
  });
</script>

</body>

</html>