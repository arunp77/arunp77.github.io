<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta content="width=device-width, initial-scale=1.0" name="viewport">

  <title>Optimization</title>
  <meta content="" name="description">
  <meta content="" name="keywords">

  <!-- Favicons -->
  <link href="assets/img/Favicon-1.png" rel="icon">
  <link href="assets/img/Favicon-1.png" rel="apple-touch-icon">

  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css?family=Open+Sans:300,300i,400,400i,600,600i,700,700i|Raleway:300,300i,400,400i,500,500i,600,600i,700,700i|Poppins:300,300i,400,400i,500,500i,600,600i,700,700i" rel="stylesheet">

  <!-- Vendor CSS Files -->
  <link href="assets/vendor/aos/aos.css" rel="stylesheet">
  <link href="assets/vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">
  <link href="assets/vendor/bootstrap-icons/bootstrap-icons.css" rel="stylesheet">
  <link href="assets/vendor/boxicons/css/boxicons.min.css" rel="stylesheet">
  <link href="assets/vendor/glightbox/css/glightbox.min.css" rel="stylesheet">
  <link href="assets/vendor/swiper/swiper-bundle.min.css" rel="stylesheet">
  <!-- Creating a python code section-->
  <link rel="stylesheet" href="assets/css/prism.css">
  <script src="assets/js/prism.js"></script>

  <!-- Template Main CSS File -->
  <link href="assets/css/style.css" rel="stylesheet">

  <!-- To set the icon, visit https://fontawesome.com/account-->
  <script src="https://kit.fontawesome.com/5d25c1efd3.js" crossorigin="anonymous"></script>
  <!-- end of icon-->

  <script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
  </script>

  <!-- =======================================================
  * Template Name: iPortfolio
  * Updated: Sep 18 2023 with Bootstrap v5.3.2
  * Template URL: https://bootstrapmade.com/iportfolio-bootstrap-portfolio-websites-template/
  * Author: BootstrapMade.com
  * License: https://bootstrapmade.com/license/
  ======================================================== -->
</head>

<body>

  <!-- ======= Mobile nav toggle button ======= -->
  <i class="bi bi-list mobile-nav-toggle d-xl-none"></i>

    <!-- ======= Header ======= -->
    <header id="header">
    <div class="d-flex flex-column">
        <div class="profile">
            <img src="assets/img/myphoto.jpeg" alt="" class="img-fluid rounded-circle">
            <h1 class="text-light"><a href="index.html">Arun</a></h1>
            <div class="social-links mt-3 text-center">
                <a href="https://www.linkedin.com/in/arunp77/" target="_blank" class="linkedin"><i class="bx bxl-linkedin"></i></a>
                <a href="https://github.com/arunp77" target="_blank" class="github"><i class="bx bxl-github"></i></a>
                <a href="https://twitter.com/arunp77_" target="_blank" class="twitter"><i class="bx bxl-twitter"></i></a>
                <a href="https://www.instagram.com/arunp77/" target="_blank" class="instagram"><i class="bx bxl-instagram"></i></a>
                <a href="https://arunp77.medium.com/" target="_blank" class="medium"><i class="bx bxl-medium"></i></a>
            </div>
        </div>

        <nav id="navbar" class="nav-menu navbar">
            <ul>
                <li><a href="index.html#hero" class="nav-link scrollto active"><i class="bx bx-home"></i> <span>Home</span></a></li>
                <li><a href="index.html#about" class="nav-link scrollto"><i class="bx bx-user"></i><span>About</span></a></li>
                <li><a href="index.html#resume" class="nav-link scrollto"><i class="bx bx-file-blank"></i><span>Resume</span></a></li>
                <li><a href="index.html#portfolio" class="nav-link scrollto"><i class="bx bx-book-content"></i><span>Portfolio</span></a></li>
                <li><a href="index.html#skills-and-tools" class="nav-link scrollto"><i class="bx bx-wrench"></i> <span>Skills and Tools</span></a></li>
                <!-- <li><a href="index.html#services" class="nav-link scrollto"><i class="bx bx-server"></i> <span>Services</span></a></li>-->
                <li><a href="index.html#professionalcourses" class="nav-link scrollto"><i class="bx bx-book-alt"></i> <span>Professional Certification</span></a></li>
                <li><a href="index.html#publications" class="nav-link scrollto"><i class="bx bx-news"></i> <span>Publications</span></a></li>
                <li><a href="index.html#extra-curricular" class="nav-link scrollto"><i class="bx bx-rocket"></i> <span>Extra-Curricular Activities</span></a></li>
                <li><a href="index.html#contact" class="nav-link scrollto"><i class="bx bx-envelope"></i> <span>Contact</span></a></li>
            </ul>
        </nav><!-- .nav-menu -->
    </div>
    </header><!-- End Header -->

    <main id="main">
        <!-- ======= Breadcrumbs ======= -->
        <section id="breadcrumbs" class="breadcrumbs"> 
          <div class="container">
    
            <div class="d-flex justify-content-between align-items-center">
              <h2>Machine Learning</h2>
              <ol>
                <li><a href="machine-learning.html" class="clickable-box">Content section</a></li>
                <li><a href="index.html#portfolio" class="clickable-box">Portfolio section</a></li>
              </ol>
            </div>
    
          </div>
        </section><!-- End Breadcrumbs -->

        <!------  right dropdown menue ------->
        <div class="right-side-list">
            <div class="dropdown">
                <button class="dropbtn"><strong>Shortcuts:</strong></button>
                <div class="dropdown-content">
                    <ul>
                        <li><a href="cloud-compute.html"><i class="fas fa-cloud"></i> Cloud</a></li>
                        <li><a href="AWS-GCP.html"><i class="fas fa-cloud"></i> AWS-GCP</a></li>
                        <li><a href="amazon-s3.html"><i class="fas fa-cloud"></i> AWS S3</a></li>
                        <li><a href="ec2-confi.html"><i class="fas fa-server"></i> EC2</a></li>
                        <li><a href="Docker-Container.html"><i class="fab fa-docker" style="color: rgb(29, 27, 27);"></i> Docker</a></li>
                        <li><a href="Jupyter-nifi.html"><i class="fab fa-python" style="color: rgb(34, 32, 32);"></i> Jupyter-nifi</a></li>
                        <li><a href="snowflake-task-stream.html"><i class="fas fa-snowflake"></i> Snowflake</a></li>
                        <li><a href="data-model.html"><i class="fas fa-database"></i> Data modeling</a></li>
                        <li><a href="sql-basics.html"><i class="fas fa-table"></i> QL</a></li>
                        <li><a href="sql-basic-details.html"><i class="fas fa-database"></i> SQL</a></li>
                        <li><a href="Bigquerry-sql.html"><i class="fas fa-database"></i> Bigquerry</a></li>
                        <li><a href="scd.html"><i class="fas fa-archive"></i> SCD</a></li>
                        <li><a href="sql-project.html"><i class="fas fa-database"></i> SQL project</a></li>
                            <!-- Add more subsections as needed -->
                    </ul>
                </div>
            </div>
        </div>

        <!-- ======= Portfolio Details Section ======= -->
        <section id="portfolio-details" class="portfolio-details">
        <div class="container">
            <div class="row gy-4">
                <h1>The Role and Importance of Optimization in Deep Learning</h1>
                <div class="col-lg-8">
                    <div class="portfolio-details-slider swiper">
                        <div class="swiper-wrapper align-items-center"> 
                            <figure>
                            <img src="assets/img/machine-ln/gradient-discent.png" alt="" style="max-width: 90%; max-height: auto;">
                            <figcaption style="text-align: center;">(<strong>Image credit: </strong> © <a href="https://www.kaggle.com/code/kanncaa1/convolutional-neural-network-cnn-tutorial">Kaggle</a>)</figcaption>
                            </figure>
                        </div>
                        <div class="swiper-pagination"></div>
                    </div>
                </div>

                <div class="col-lg-4 grey-box">
                    <div class="section-title">
                        <h3>Content</h3>
                        <ol>
                            <li><a href="#introduction">Introduction</a></li>
                            <ul>
                                <li><a href="#reasons">Optimization in deep learning is vital for several reasons</a></li>
                                <li><a href="#opti-work">Optimization at work</a></li>
                            </ul>
                            <li><a href="#optimization-dl">Optimization Methods in Deep Learning</a></li>
                            <ul>
                                <li><a href="#Terminologies">Terminologies</a></li>
                                <li><a href="#gd">1. Gradient Descent (GD)</a></li>
                                <li><a href="#sgd">2. Stochastic Gradient Descent (SGD)</a></li>
                                <li><a href="#mgd">3. Mini-batch Gradient Descent</a></li>
                                <li><a href="#momentum">4. Momentum</a></li>
                                <li><a href="#adam">5. Adam (Adaptive Moment Estimation)</a></li>
                                <li><a href="#rmsprop">6. RMSprop (Root Mean Square Propagation)</a></li>
                            </ul>
                            <li><a href="#reference">Reference</a></li>
                        </ol>
                    </div>
                </div>
            </div>

            <section>
            <h3 id="introduction">Introduction</h3>
            Optimization lies at the heart of deep learning, playing a crucial role in training neural networks to achieve high performance on various tasks such as image classification, 
            natural language processing, and 
            reinforcement learning. By iteratively adjusting the parameters of a neural network, optimization algorithms seek to minimize a predefined objective function, often referred 
            to as the loss or cost function. 
            <p>This process involves finding the optimal set of parameters that result in the best possible model performance.</p>
            
            <p>Below, I will discuss the role and importance of optimization techniques in deep learning.</p>
            
            <!------------------------->
            <h5 id="reasons">Optimization in deep learning is vital for several reasons:</h5>
            <ul>
                <li><strong>Model Convergence:</strong> Effective optimization ensures that the training process converges to a set of parameters where the model exhibits satisfactory 
                    performance on unseen data.</li>
                <li><strong>Enhanced Performance:</strong> Well-optimized models tend to achieve higher accuracy, better generalization, and faster convergence during training.</li>
                <li><strong>Scalability:</strong> Optimization algorithms need to scale efficiently to handle large datasets and complex neural network architectures commonly encountered 
                    in deep learning tasks.</li>
                <li><strong>Robustness:</strong> Robust optimization methods help neural networks avoid overfitting and learn meaningful representations from data, leading to improved 
                    performance on diverse tasks. </li>
            </ul>


            <!--------------------->
            <h5 id="opti-work">Optimization at work</h5>
            Optimization algorithms iteratively update model weights to minimize the loss function. Here's a  simplified description of the process:
            <ul>
                <li><strong>Forward Pass:</strong> Data flows through the network, generating predictions.</li>
                <li><strong>Loss Calculation:</strong> The loss function compares the predictions against desired outputs, measuring error.</li>
                <li><strong>Backpropagation:</strong> The error signals are propagated back through the network, calculating "gradients" that indicate how weights should change to reduce the loss.</li>
                <li><strong>Weight Update:</strong> The optimizer (e.g., gradient descent, Adam) uses the gradients to update the network's weights.</li>
            </ul>


            <!--------------------------->
            <h3 id="optimization-dl">Optimization Methods in Deep Learning</h3>
            <p>In deep learning, optimizers are crucial as algorithms that dynamically fine-tune a model’s parameters throughout the training process, aiming to minimize a predefined loss 
                function. These specialized 
            algorithms facilitate the learning process of neural networks by iteratively refining the weights and biases based on the feedback received from the data. Well-known optimizers 
            in deep learning encompass 
            Stochastic Gradient Descent (SGD), Adam, and RMSprop, each equipped with distinct update rules, learning rates, and momentum strategies, all geared towards the overarching goal 
            of discovering and converging 
            upon optimal model parameters, thereby enhancing overall performance.</p>
            <p><strong>Optimizers: </strong>During the training of deep learning models, optimizers play a crucial role by adjusting parameters like weights and learning rates to minimize 
                the loss function and enhance accuracy. 
                As deep learning models typically contain millions of parameters, selecting the right optimizer is a challenging task. Understanding various optimization algorithms 
                is essential for data scientists to effectively 
                navigate the field. Different optimizers can be employed in machine learning models to alter weights and learning rates. However, the choice of the best optimizer depends on 
                the specific application. While it may 
                seem tempting for beginners to experiment with various optimizers and select the one yielding the best results, this approach becomes impractical when dealing with large datasets. 
                Randomly selecting an optimizer 
                can lead to significant time wastage, akin to gambling with valuable resources. Therefore, it's crucial to make informed decisions when choosing optimizers to avoid unnecessary 
                delays and optimize training efficiency.
            </p>

            <!----------------->
            <h5 id="Terminologies">Terminologies</h5>
            <ul>
                <li><strong>Model:</strong> A mathematical function that transforms inputs into outputs, incorporating a set of adjustable parameters and an accompanying algorithm for optimization.</li>
                <li><strong>Model Parameter:</strong> A tunable element within a neural network, utilized to refine the accuracy and efficiency of the model. Common instances include weights and 
                    biases in a feedforward neural network, which are adjusted during training to optimize performance.</li>
                <li><strong>Epoch:</strong> The number of times the algorithm runs on the whole training dataset.</li>
                <li><strong>Sample:</strong> A single row of a dataset</li>
                <li><strong>Batch: </strong> It denotes the number of samples to be taken to for updating the model parameters.</li>
                <li><strong>Learning rate:</strong> It is a parameter that provides the model a scale of how much model weights should be updated.</li>
                <li><strong>Cost function/Loss function: </strong> A cost function is used to calculate the cost, which is the difference between the predicted value and the actual value.</li>
                <li><strong>Weights/bias:</strong> The learnable parameters in a model that controls the signal between two neurons.</li>
            </ul>
                
            <p>Now let’s explore each optimizer.</p>
            <figure>
                <img src="assets/img/machine-ln/optimization-trajectory.png" alt="" style="max-width: 100%; max-height: auto;">
                <figcaption style="text-align: center;">Various optimization methods. This is just for representation purpose. Here choosen cost function is of the form \(x^2\). (<strong>Image credit: </strong> @ <a href="https://github.com/arunp77/Machine-Learning/tree/main/Deep-learning" target="_blank">Arunp77</a>).</figcaption>
            </figure>

            <!-------------------------------------->
            <div class="box" style="border: 1px solid black;">
                <h4 id="gd">1. Gradient Descent (GD): </h4> 
                <div class="important-box"><i class="fa fa-info-circle"></i> &emsp; For more details on this method in the context of linear regression can be found at <a href="Linear-reg.html">link</a>.</div><br>
                
                <div class="box">
                    <figure>
                        <img src="assets/img/machine-ln/deep-gd-method.png" alt="" style="max-width: 80%; max-height: auto;">
                        <figcaption style="text-align: center;">(<strong>Image credit: </strong> @ <a href="index.html" target="_blank">Arunp77</a>).</figcaption>
                    </figure>
                    <strong>Image description: </strong>In Gradient Descent, model parameters start randomly and are updated iteratively to minimize the cost function. The step size decreases as the cost approaches 
                    its minimum (first image). A high learning rate can cause the algorithm to overshoot the minimum and end up on the opposite side of a valley, potentially even higher than the initial position. This can lead to divergence, with the algorithm producing increasingly larger values and failing to find an optimal solution.
                    In non-ideal scenarios, the cost function may have irregular shapes like holes, ridges, or plateaus, making convergence to the minimum challenging. In the case of the third image with local and global minimum structures, starting the algorithm on the left may lead to convergence to a local minimum, which is inferior 
                    to the global minimum. Conversely, starting on the right at the plateau could prolong the convergence process significantly. Moreover, stopping too early may prevent reaching the global minimum altogether.
                </div><br>
    
                <ol>
                    <li><strong>Objective: </strong>Gradient Descent is an iterative optimization algorithm used to minimize a given cost function \(J(\theta)\) by adjusting the parameters 
                        \(\theta\) iteratively.</li>
                    <li><strong>Components: </strong>
                        <ul class="lower-alpha">
                            <li><strong>Cost Function (Loss Function): </strong> \(J(\theta_t)\) represents the cost function or loss function that measures how well the model performs on the 
                                training data with respect to its parameters \(\theta\).</li>
                            <li><strong>Gradient: </strong>The gradient of the cost function \(J(\theta)\) with respect to the parameters \(\theta\), denoted by \(\nabla J(\theta)\), 
                                represents the direction of the steepest ascent. The negative gradient \(-\nabla J(\theta)\) points in the direction of the steepest descent, i.e., 
                                the direction in which the function decreases most rapidly.</li>
                            <li><strong>Learning rate (\(\eta\)): </strong>\(\eta\)  is a hyperparameter known as the learning rate. It determines the size of the steps taken in the 
                                parameter space during each iteration of the optimization process.</li>
                        </ul>
                    </li>
                    <li><strong>Steps: </strong>
                        <ul class="lower-alpha">
                            <li><strong>Initialization: </strong>Initialize the parameters \(\theta\) randomly or with certain pre-defined values.</li>
                            <li><strong>Compute Gradient: </strong>Calculate the gradient of the cost function \(J(\theta)\) with respect to the parameters \(\theta\) at the current parameter values</li>
                            <li><strong>Update Parameters: </strong>Update the parameters \(\theta\) in the opposite direction of the gradient by taking a step proportional to the 
                                negative gradient and the learning rate. This step is expressed by the formula:
                            $$\theta_{t+1} = \theta_t - \eta \nabla J(\theta_t)$$
                            where
                            <ul>
                                <li>\(\theta_{t+1}\) is the updated value of parameters at iteration \(t+1\).</li>
                                <li>\(\theta_t\) is the current value of parameters at iteration \(t\).</li>
                                <li>\(\nabla J(\theta_t)\) is the </li>
                                <li>\(\eta\) is the learning rate</li>
                            </ul>
                            </li>
                            <li><strong>Repeat</strong></li>
                        </ul>
                    </li>
                    <li><strong>Convergence: </strong>Convergence occurs when the algorithm reaches a point where further updates to the parameters do not significantly reduce the value of the 
                        
                        cost function.</li>
                    <li><strong>Summary: </strong>Gradient Descent iteratively updates the parameters \(\theta\) in the direction of the steepest descent of the cost function, aiming to minimize 
                        the cost function and thereby optimize the model.</li>
                    <li><strong>Variants: </strong>Various variants of Gradient Descent, such as Stochastic Gradient Descent (SGD), Mini-batch Gradient Descent, Momentum, Adam, and RMSprop, 
                        introduce modifications to the basic algorithm to improve convergence speed, stability, and efficiency.</li>
                </ol>
                In summary, Gradient Descent is a fundamental optimization algorithm in machine learning used to minimize a cost function by iteratively adjusting the parameters in the 
                direction opposite to the gradient of the cost function, scaled by a learning rate.
            </div><br>
            <div class="box" style="background-color: rgb(214, 226, 230); border: 1px solid black;"> 
                <h4 id="sgd">2. Stochastic Gradient Descent (SGD): </h4>
                <ol>
                    <li><strong>Objective: </strong>SGD is an optimization algorithm commonly used in machine learning and deep learning for training models. It aims to minimize a given loss 
                        function by iteratively updating the model parameters. </li>
                    <li><strong>Basic Idea:: </strong>Instead of computing the gradient of the loss function over the entire dataset (as in batch gradient descent), SGD computes the gradient 
                        over a single random training example at each iteration.</li>
                    <li><strong>Algorithm: </strong>
                        <ul>
                            <li><strong>Initialization: </strong>Start with initial parameter values \(\theta_0\).</li>
                            <li><strong>Loop: </strong>Repeat until convergence or for a fixed number of iterations: 
                                <ul class="upper-alpha">
                                    <li>Randomly shuffle the training dataset.</li>
                                    <li>For each training example \(i\) in the dataset:
                                        <ul class="roman">
                                            <li>Compute the gradient of the loss function with respect to the parameters using the current example: \(\nabla J(\theta_{t, i})\).</li>
                                            <li>Update the parameters using the gradient descent update rule:</li>
                                            $$\theta_{t+1} = \theta_t - \eta \nabla J(\theta_{t,i})$$
                                            where:
                                            <ul>
                                                <li>\(\theta_t\) is the parameter vector at iteration \(t\).</li>
                                                <li>\(\eta\) is the learning rate, determining the step size.</li>
                                            </ul>
                                        </ul>
                                    </li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li><strong>Key Aspects: </strong>
                        <ul>
                            <li><strong>Randomness: </strong>SGD introduces randomness by using a random training example at each iteration. This randomness helps escape local minima and can 
                                lead to faster convergence, especially in large datasets.</li>
                            <li><strong>Efficiency: </strong>Since only one training example is processed per iteration, SGD is computationally efficient and can handle large datasets that may 
                                not fit into memory.</li>
                            <li><strong>Noisy Updates: </strong>Due to the randomness, SGD updates can be noisy, leading to oscillations around the optimal solution. However, this noise can 
                                sometimes help the optimization process by escaping sharp local minima.</li>
                            <li><strong>Learning Rate Tuning: </strong>The learning rate \(\eta\) plays a crucial role in SGD. Choosing an appropriate learning rate is essential for convergence. 
                                It may need to be tuned during training using techniques like learning rate schedules or adaptive learning rate methods.</li>
                        </ul>
                    </li>
                    <li><strong>Formula: </strong> The update rule for SGD using a single training example \(i\) can be represented as:
                        $$\theta_{t+1} = \theta_{t} - \eta \nabla J(\theta_{t,i})$$
                        where:
                        <ul>
                            <li>\(\theta_t\) is the parameter vector at iteration \(t\).</li>
                            <li>\(\eta\) is the learning rate.</li>
                            <li>\(\nabla J(\theta_{t,i})\) is the gradient of the loss function with respect to the parameters computed using the \(i-\)th training example.</li>
                        </ul>
                    </li>
                    <li><strong>Advantages: </strong>
                        <ul>
                            <li><strong>Efficiency: </strong>SGD is computationally efficient, making it suitable for large-scale datasets.</li>
                            <li><strong>Generalization: </strong>It often leads to better generalization since it avoids overfitting by updating parameters frequently with different examples.</li>
                            <li><strong>Parallelism: </strong>SGD is inherently parallelizable, allowing for efficient implementation on parallel computing architectures.</li>
                        </ul>
                    </li>
                    <li><strong>Disadvantages: </strong>
                        <ul>
                            <li><strong>Noisy Updates: </strong>The randomness in SGD updates can lead to noisy convergence, making it challenging to find the exact optimal solution.</li>
                            <li><strong>Learning Rate Tuning: </strong>Proper tuning of the learning rate is crucial for stable convergence. An inappropriate learning rate can lead to slow 
                                convergence or divergence.</li>
                            <li><strong>Sensitive to Scaling: </strong>SGD can be sensitive to feature scaling, requiring careful preprocessing of the input data.</li>
                        </ul>
                    </li>
                </ol>
                In summary, Stochastic Gradient Descent (SGD) is a popular optimization algorithm in machine learning and deep learning, known for its efficiency and ability to handle large datasets. 
                Despite its noisy updates and sensitivity to learning rate, SGD remains a fundamental and widely used optimization method in practice.
            </div><br>

            <div class="box" style="background-color: rgba(1, 243, 231, 0.226); border: 1px solid black;">
                <h4 id="mgd">3. Mini-batch Gradient Descent: </h4> 
                Mini-batch Gradient Descent (MBGD) is a variation of the traditional Gradient Descent algorithm that updates the model parameters using mini-batches of training data instead of the entire dataset at once. This approach combines the efficiency of Stochastic Gradient Descent (SGD) with the stability of Gradient Descent (GD). Here's a detailed explanation of MBGD along with the relevant formulas:
                <ol>
                    <li><strong>Overview: </strong>Mini-batch Gradient Descent divides the training data into small batches of size \(n\). Instead of computing the gradient on the entire dataset (GD) on on a single data point (SGD), MBGD computes the gradient on a mini-batch of training examples.</li>
                    <li><strong>Formulation: </strong>Let's consider a dataset with \(m\) training examples. The cost function \(J(\theta)\) measures the difference between the model predictions and the actual targets. The update rule for Mini-batch Gradient Descent at iteration \(t\) is given by:</li>
                    $$\theta_{t+1} = \theta_t - \eta \nabla J(\theta_{t,i:i+n})$$
                    where:
                        <ul>
                            <li>\(\theta_t\) is the parameter vector at iteration \(t\).</li>
                            <li>\(\eta\) is the learning rate.</li>
                            <li>\(\nabla J(\theta_{t,i:i+n})\) is the gradient of the cost function \(j(\theta)\) computed on the mini-batch \(i:i+n\).</li>
                        </ul>
                    <li><strong>Algorithm Steps: </strong>
                        <ul class="lower-alpha">
                            <li><strong>Initialization: </strong>Initialize the model parameters \(\theta\)  and hyperparameters like the learning rate \(\eta\).</li>
                            <li><strong>Mini-batch Formation: </strong>Randomly shuffle the training data and divide it into mini-batches of size \(n\). If the dataset size is not divisible by \(n\), the last mini-batch may have fewer examples.</li>
                            <li><strong>Gradient Computation: </strong>For each mini-batch \(i : i+n\), compute the gradient of the cost function \(J(\theta)\) with respect to the parameters \(\theta\):</li>
                            $$\nabla J(\theta_{t,i:i+n}) = \frac{1}{n} \sum_{j=i}^{i+n} \nabla J(\theta_{t},x_j, y_j)$$
                            where (\(x_j,y_j\)) are the input features and corresponding target labels in the min-batch.
                            <li><strong>Parameter Update: </strong>Update the parameter \(\theta\) using the computed gradient:</li>
                            $$\theta_{t+1} = \theta_t - \eta \nabla J(\theta_{t,i:i+n})$$
                            <li><strong>Repeat: </strong>Repeat steps <strong>(c)</strong> and <strong>(d)</strong> for a fixed number of iterations or until convergence criteria are met.</li>
                        </ul>
                    </li>
                    <li><strong>Benefits of Mini-batch Gradient Descent: </strong>
                        <ul>
                            <li><strong>Efficiency: </strong>MBGD utilizes vectorized operations, making it computationally efficient compared to SGD.</li>
                            <li><strong>Stability: </strong> It offers more stable convergence than SGD as it considers a mini-batch of examples.</li>
                            <li><strong>Memory Usage: </strong> It allows for efficient memory usage by processing only a subset of data at a time.</li>
                        </ul>
                    </li>
                    <li><strong>Hyperparameter Tuning: </strong>
                        <ul>
                            <li><strong>Batch Size \(n\): </strong>The choice of mini-batch size affects the convergence speed and memory requirements.</li>
                            <li><strong>Learning Rate \(\eta\): </strong>The learning rate determines the step size during parameter updates and impacts convergence.</li>
                        </ul>
                    </li>
                </ol>
                In summary, Mini-batch Gradient Descent is a popular optimization algorithm in deep learning that strikes a balance between efficiency and stability by updating model parameters using mini-batches of training data.
            </div><br>

            <div class="box" style="background-color: rgba(10, 214, 78, 0.226);">
                <h4 id="momentum">4. Momentum: </h4> 
                Momentum is an optimization technique that helps accelerate gradient descent algorithms in the relevant direction and dampens oscillations. It accomplishes this by adding a fraction of the previous update vector to the current gradient. This helps to smooth out the steps taken during optimization, especially when the cost surface has high curvature or noisy gradients.
                <p>Here's a detailed explanation of Momentum along with the formulas involved:</p>
                <ol>
                    <li><strong>Update Formulas: </strong>
                        <ul>
                            <li>Momentum introduces a variable \(v\) which accumulates the gradients of the past steps.</li>
                            <li>The update for \(v\) at each iteration \(t\) is given by:</li>
                            $$v_{t+1}= \beta v_t + (1-\beta) \nabla J(\theta_t)$$
                            where:
                                <ul>
                                    <li>\(v_t\) is the momentum at time step \(t\),</li>
                                    <li>\(\nabla J(\theta_t)\) is the gradient of the cost function \(J\) with respect to the parameters \(\theta\) at time step \(t\),</li>
                                    <li>\(\beta\) is the momentum parameter, typically set to a value close to 1, e.g., 0.9.</li>
                                </ul>
                            <li>Then, the parameter \(\theta\) are updated using the momentum term:
                                $$\theta_{t+1} = \theta_t - \eta v_{t+1}$$
                                where \(\eta\) is the learning rate.
                            </li>
                        </ul>
                    </li>
                    <li><strong>Explanation of Formulas: </strong>
                        <ul>
                            <li>The first term in the update equation for \(v\) is the momentum term (\(\beta v_t\)), which is the previous momentum scaled by the momentum parameter \(\beta\).</li>
                            <li>The second term in the update equation is the gradient of the cost function scaled by (1-\(\beta\)), which gives the contribution of the current gradient.</li>
                            <li>The momentum term effectively remembers the direction of previous gradients and reinforces the current direction if gradients keep pointing in the same direction, thus helping to speed up convergence.</li>
                            <li>If the gradients keep changing direction (e.g., during oscillations), the momentum term helps to smooth out these oscillations by accumulating gradients in a consistent direction.</li>
                        </ul>
                    </li>
                    <li><strong>Advantages of Momentum: </strong>
                        <ul>
                            <li>Helps accelerate convergence, especially in the presence of high curvature or noisy gradients.</li>
                            <li>Dampens oscillations and overshooting in the optimization process, leading to more stable and efficient training.</li>
                            <li>Helps to escape local minima or saddle points by accumulating momentum to push through flat regions.</li>
                        </ul>
                    </li>
                    <li><strong>Choosing the Momentum Parameter \(\beta\): </strong>
                        <ul>
                            <li>The momentum parameter \(\beta\) typically ranges from 0.8 to 0.999.</li>
                            <li>A higher value of \(\beta\) takes the algorithm more "momentum-heavy," which can help in smoothing our oscillations but might overshoot minima.</li>
                            <li>A lower value of \(\beta\) makes the algorithm more responsive to recent gradients but might slow down convergence.</li>
                        </ul>
                    </li>
                </ol>
                In summary, Momentum is a powerful optimization technique in deep learning that improves convergence speed and stability by incorporating information from previous gradients. It is widely used in conjunction 
                with gradient descent-based optimization algorithms like SGD and Adam.
            </div><br>

            <div class="box" style="background-color: rgba(243, 207, 1, 0.226);">
                <h4 id="adam">5. Adam (Adaptive Moment Estimation): </h4>
                Adam (Adaptive Moment Estimation) is an optimization algorithm commonly used in deep learning, known for its adaptive learning rate and momentum properties. It combines the advantages of two other popular optimization algorithms, RMSprop and Momentum, to efficiently navigate the parameter space during training. Let's delve into the details of Adam and explain its various components using formulas:
                <p><strong>Algorithm Overview:</strong></p>
                <ol>
                    <li><strong>Initialization: </strong>First Initialize parameters:
                        <ul>
                            <li>\(\theta_0\): Model parameters (weights and biases).</li>
                            <li>\(m_0\) = 0: Initial first moment vector (mean),</li>
                            <li>\(v_0\) =0: Initial second moment vector (uncentered variance).</li>
                            <li>\(\beta_1, \beta_2 \in [0,1)\): Exponential decay rates for moment estimates.</li>
                            <li>\(\eta\): Learning rate.</li>
                            <li>\(\epsilon\): small constant to prevent division by zero. Defaults to 1e-8.</li>
                        </ul> 
                    </li>
                    <li><strong>Update at each time step \(t\): </strong>
                        <ul>
                            <li>Compute gradient:</li>
                            $$g_t = \nabla J(\theta_t)$$
                            where \(J\) is the loss function.
                            <li>Update biased first moment estimate:</li>
                            $$m_t = \beta_1\cdot m_{t-1} +(1-\beta_1)\cdot g_t$$
                            <li>Update biased second raw moment estimate: </li>
                            $$v_t = \beta_2 \cdot v_{t-1} + (1-\beta_2)\cdot g_t^2$$
                            <li>Correct bias in first moment: </li>
                            $$\hat{m}_t = \frac{m_t}{1-\beta_1^t}.$$
                            <li>Correct bias in second moment: </li>
                            $$\hat{v}_t = \frac{v_t}{1-\beta_2^t}$$
                            <li>Update parameters: </li>
                            $$\theta_{t+1} = \theta_t - \eta\cdot \frac{\hat{m}_t}{\sqrt{\hat{v}_t}+\epsilon} $$
                        </ul>
                    </li>
                </ol>
                <p><strong>Detailed Explanation of Formulas:</strong></p>
                <ol>
                    <li><strong>First Moment Estimation (Mean): </strong></li>
                    $$m_t = \beta_1 \cdot m_{t-1} +(1-\beta_1)\cdot g_t$$
                    where:
                        <ul>
                            <li>\(m_t\): Biased first moment estimate (mean of gradients)</li>
                            <li>\(\beta_1\): Exponential decay rate for the first moment.</li>
                            <li>\(g_t\): Gradient at time step.</li>
                        </ul>
                    <li><strong>Second Moment Estimation (Uncentered Variance):  </strong></li>
                    $$v_t = \beta_2 \cdot v_{t-1}+(1-\beta_2)\cdot g_t^2$$
                    where:
                        <ul>
                            <li>\(v_t\): Biased second raw moment estimate (uncentered variance of gradients).</li>
                            <li>\(\beta_2\): Exponential decay rate for the second moment.</li>
                            <li>\(g_t^2\): Element-wise square of the gradient at time step \(t\).</li>
                        </ul>
                    <li><strong>Bias Correction:</strong></li>
                    $$\hat{m}_t = \frac{m_t}{1-\beta_1^t}$$
                    and 
                    $$\hat{v}_t = \frac{v_t}{1-\beta_2^t}.$$
                    where:
                        <ul>
                            <li>Corrects bias in the first and second moment estimates, especially during the initial time steps when \(m_t\) and \(v_t\) are biased towards zero.</li>
                        </ul>
                    <li><strong>Parameter Update: </strong></li>
                    $$\theta_{t+1} = \theta_t -\eta \cdot \frac{\hat{m}_t}{\sqrt{\hat{v}_t}+\epsilon}.$$
                    where:
                        <ul>
                            <li>Corrects bias in the first and second moment estimates, especially during the initial time steps when \(m_t\) and \(v_t\) are biased towards zero.</li>
                        </ul>
                    <li><strong>Parameter Update: </strong></li>
                    $$\theta_{t+1} = \theta_t - \eta\cdot \frac{\hat{m}_t}{\sqrt{\hat{v}_t}+\epsilon}.$$
                    <ul>
                        <li>Updates the model parameters using the corrected first and second moment estimates.</li>
                        <li>\(\eta\): Learning rate.</li>
                        <li>\(\epsilon\): Small constant to prevent division by zero.</li>
                    </ul>
                </ol> 
                <p><strong>Key Features:</strong></p>
                <ul>
                    <li><strong>Adaptive Learning Rate: </strong>The learning rate is adjusted for each parameter based on the estimates of the first and second moments of the gradients.</li>
                    <li><strong>Bias Correction: </strong>Adam corrects the bias in the moment estimates, especially at the beginning of training.</li>
                    <li><strong>Momentum: </strong>The first moment term \(m_t\) acts like a momentum term, allowing the algorithm to accelerate in the relevant direction and dampen oscillations.</li>
                    <li><strong>Efficiency: </strong>Adam is computationally efficient and requires little memory.</li>
                </ul>
                Adam has become a popular choice for optimizing deep neural networks due to its adaptive learning rate and momentum properties, which often result in faster convergence and better performance.
            </div><br>

            <div class="box" style="background-color: rgba(243, 1, 13, 0.226);">
                <h4 id="rmsprop">6. RMSprop (Root Mean Square Propagation): </h4> 
                RMSprop (Root Mean Square Propagation) is an optimization algorithm commonly used in deep learning to adaptively adjust the learning rates for each parameter. It addresses some of the limitations of other optimization algorithms, particularly when dealing with sparse data and non-stationary objectives. Here's a detailed explanation of RMSprop along with formulas:
                <p><strong>Overview: </strong>RMSprop is an extension of the gradient descent optimization algorithm that aims to improve convergence speed and stability, especially in the presence of sparse gradients or noisy data. It accomplishes this by adjusting the learning rates of each parameter individually based on the magnitude of recent gradients.</p>
                <p><strong>Algorithm Steps: </strong></p>
                <ol>
                    <li><strong>Initialize Parameters: </strong>Initialize model parameters \(\theta\), typically randomly or using pre-trained values. Initialize a decay rate \(\beta\), usually close to 1, and a small constant \(\epsilon\) for numerical stability.</li>
                    <li><strong>Initialize Variables: </strong>Initialize an accumulation variable \(v\) to store the exponentially weighted moving average (EWMA) of squared gradients.</li>
                    <li><strong>Compute Gradients: </strong>Compute the gradients of the loss function with respect to the parameters \(\nabla J(\theta)\) using backpropagation.</li>
                    <li><strong>Update Accumulation: </strong>Update the accumulation variable \(v\) by taking an EWMA of the squared gradients:</li>
                    $$v = \beta v+(1-\beta)(\nabla J(\theta))^2$$
                    where \(\beta\) is the decay rate \((\nabla J(\theta))^2\) represents element-wise squaring of the gradients.
                    <li><strong>Update Parameters: </strong>Update the parameters \(\theta\) using the RMSprop update rule:</li> 
                    $$\theta = \theta - \eta \frac{\nabla J(\theta)}{\sqrt{v}+\epsilon}$$
                    where \(\eta\) is the learning rate and \(\epsilon\) is a small constant added for numerical stability to avoid division by zero.
                </ol>
                <p><strong>Detailed Explanation: </strong></p>
                <ol>
                    <li><strong>Accumulation of Squared Gradients \(v\): </strong>RMSprop maintains an exponentially decaying average of squared gradients using the parameter \(\beta\). This moving average helps smooth out the gradient updates and adaptively adjust the learning rates.</li>
                    <li><strong>Normalization of Gradients: </strong>Before updating the parameters, RMSprop normalizes the gradients by dividing them by the square root of the accumulated squared gradients plus a small constant \(\epsilon\). This Normalization scales down the learning rates for parameters with large gradients and vice versa.</li>
                    <li><strong>Adaptive Learning Rates: </strong>By adjusting the learning rates based on the magnitude of gradients, RMSprop adapts to the geometry of the loss function and speeds up convergence, especially in deep neural networks with complex and non-convex surfaces.</li>
                </ol>
                <p><strong>Key Advantages: </strong></p>
                <ol>
                    <li><strong>Adaptive Learning Rates: </strong>RMSprop adapts the learning rates for each parameter individually based on the recent gradient history, leading to faster convergence and improved stability.</li>
                    <li><strong>Sparse Data Handling: </strong>The algorithm performs well with sparse data or noisy gradients, thanks to its adaptive nature and normalization of gradients.</li>
                    <li><strong>Robustness: </strong>RMSprop is robust to variations in hyperparameters and works well across different architectures and datasets.</li>
                </ol>
                <p><strong>Summary: </strong></p>
                RMSprop is a powerful optimization algorithm widely used in training deep neural networks. By adaptively adjusting learning rates based on the magnitude of gradients, it addresses some of the challenges faced by traditional gradient descent methods, leading to faster convergence and improved performance.
            </div>

            <!-------Reference ------->
            <section id="reference">
                <h3>References</h3>
                <ol>
                    <li><a href="https://hamdi-ghorbel78.medium.com/deep-learning-optimization-techniques-3257b51accd0" target="_blank">“Deep Learning”: Optimization Techniques</a>.</li>
                    <li><a href="https://developer.ibm.com/articles/cc-machine-learning-deep-learning-architectures/" target="_blank">Deep learning architectures</a></li>
                    <li>Hands on Machine Learning with Scikit-Learn, Keras, & TensorFlow, Aurelien Geron</li>
                </ol> 
            </section>

            <hr>
        
            <div style="background-color: #f0f0f0; padding: 15px; border-radius: 5px;">

                <h3>Some other interesting things to know:</h3>
                <ul style="list-style-type: disc; margin-left: 30px;">
                    <li>Look at <a href="deep-learning.html">my Deep Learning page</a>.</li>
                    <li>Visit my website on <a href="sql-project.html">For Data, Big Data, Data-modeling, Datawarehouse, SQL, cloud-compute.</a></li>
                    <li>Visit my website on <a href="Data-engineering.html">Data engineering</a></li>
                </ul>
            </div>
            <p></p>

            <div class="navigation">
                <a href="index.html#portfolio" class="clickable-box">
                    <span class="arrow-left">Portfolio section</span>
                </a>
                
                <a href="machine-learning.html" class="clickable-box">
                    <span class="arrow-right">Content</span>
                </a>
            </div>
        </div>
        </section><!-- End Portfolio Details Section -->
    </main><!-- End #main --

    <!-- ======= Footer ======= -->
    <footer id="footer">
    <div class="container">
        <div class="copyright">
        &copy; Copyright <strong><span>Arun</span></strong>
        </div>
    </div>
    </footer><!-- End  Footer -->

    <a href="#" class="back-to-top d-flex align-items-center justify-content-center"><i class="bi bi-arrow-up-short"></i></a>

    <!-- Vendor JS Files -->
    <script src="assets/vendor/purecounter/purecounter_vanilla.js"></script>
    <script src="assets/vendor/aos/aos.js"></script>
    <script src="assets/vendor/bootstrap/js/bootstrap.bundle.min.js"></script>
    <script src="assets/vendor/glightbox/js/glightbox.min.js"></script>
    <script src="assets/vendor/isotope-layout/isotope.pkgd.min.js"></script>
    <script src="assets/vendor/swiper/swiper-bundle.min.js"></script>
    <script src="assets/vendor/typed.js/typed.umd.js"></script>
    <script src="assets/vendor/waypoints/noframework.waypoints.js"></script>
    <script src="assets/vendor/php-email-form/validate.js"></script>

    <!-- Template Main JS File -->
    <script src="assets/js/main.js"></script>

    <script>
    document.addEventListener("DOMContentLoaded", function () {
        hljs.initHighlightingOnLoad();
    });
    </script>

</body>

</html>