<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta content="width=device-width, initial-scale=1.0" name="viewport">

  <title>Unite testing</title>
  <meta content="" name="description">
  <meta content="" name="keywords">

  <!-- Favicons -->
  <link href="assets/img/Favicon-1.png" rel="icon">
  <link href="assets/img/Favicon-1.png" rel="apple-touch-icon">

  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css?family=Open+Sans:300,300i,400,400i,600,600i,700,700i|Raleway:300,300i,400,400i,500,500i,600,600i,700,700i|Poppins:300,300i,400,400i,500,500i,600,600i,700,700i" rel="stylesheet">

  <!-- Vendor CSS Files -->
  <link href="assets/vendor/aos/aos.css" rel="stylesheet">
  <link href="assets/vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">
  <link href="assets/vendor/bootstrap-icons/bootstrap-icons.css" rel="stylesheet">
  <link href="assets/vendor/boxicons/css/boxicons.min.css" rel="stylesheet">
  <link href="assets/vendor/glightbox/css/glightbox.min.css" rel="stylesheet">
  <link href="assets/vendor/swiper/swiper-bundle.min.css" rel="stylesheet">
  <!-- Creating a python code section-->
  <link rel="stylesheet" href="assets/css/prism.css">
  <script src="assets/js/prism.js"></script>

  <!-- Template Main CSS File -->
  <link href="assets/css/style.css" rel="stylesheet">

  <!-- To set the icon, visit https://fontawesome.com/account-->
  <script src="https://kit.fontawesome.com/5d25c1efd3.js" crossorigin="anonymous"></script>
  <!-- end of icon-->

  <!-- =======================================================
  * Template Name: iPortfolio
  * Updated: Sep 18 2023 with Bootstrap v5.3.2
  * Template URL: https://bootstrapmade.com/iportfolio-bootstrap-portfolio-websites-template/
  * Author: BootstrapMade.com
  * License: https://bootstrapmade.com/license/
  ======================================================== -->
</head>

<body>

  <!-- ======= Mobile nav toggle button ======= -->
  <i class="bi bi-list mobile-nav-toggle d-xl-none"></i>

  <!-- ======= Header ======= -->
  <header id="header">
    <div class="d-flex flex-column">

      <div class="profile">
        <img src="assets/img/myphoto.jpeg" alt="" class="img-fluid rounded-circle">
        <h1 class="text-light"><a href="index.html">Arun</a></h1>
        <div class="social-links mt-3 text-center">
          <a href="https://www.linkedin.com/in/arunp77/" target="_blank" class="linkedin"><i class="bx bxl-linkedin"></i></a>
          <a href="https://github.com/arunp77" target="_blank" class="github"><i class="bx bxl-github"></i></a>
          <a href="https://twitter.com/arunp77_" target="_blank" class="twitter"><i class="bx bxl-twitter"></i></a>
          <a href="https://www.instagram.com/arunp77/" target="_blank" class="instagram"><i class="bx bxl-instagram"></i></a>
          <a href="https://arunp77.medium.com/" target="_blank" class="medium"><i class="bx bxl-medium"></i></a>
        </div>
      </div>

      <nav id="navbar" class="nav-menu navbar">
        <ul>
          <li><a href="index.html#hero" class="nav-link scrollto active"><i class="bx bx-home"></i> <span>Home</span></a></li>
          <li><a href="index.html#about" class="nav-link scrollto"><i class="bx bx-user"></i> <span>About</span></a></li>
          <li><a href="index.html#resume" class="nav-link scrollto"><i class="bx bx-file-blank"></i> <span>Resume</span></a></li>
          <li><a href="index.html#portfolio" class="nav-link scrollto"><i class="bx bx-book-content"></i> <span>Portfolio</span></a></li>
          <li><a href="index.html#skills-and-tools" class="nav-link scrollto"><i class="bx bx-wrench"></i> <span>Skills and Tools</span></a></li>
          <li><a href="index.html#language" class="nav-link scrollto"><i class="bi bi-menu-up"></i> <span>Languages</span></a></li>
          <li><a href="index.html#awards" class="nav-link scrollto"><i class="bi bi-award-fill"></i> <span>Awards</span></a></li>
          <li><a href="index.html#professionalcourses" class="nav-link scrollto"><i class="bx bx-book-alt"></i> <span>Professional Certification</span></a></li>
          <li><a href="index.html#publications" class="nav-link scrollto"><i class="bx bx-news"></i> <span>Publications</span></a></li>
          <li><a href="index.html#extra-curricular" class="nav-link scrollto"><i class="bx bx-rocket"></i> <span>Extra-Curricular Activities</span></a></li>
          <!-- <li><a href="#contact" class="nav-link scrollto"><i class="bx bx-envelope"></i> <span>Contact</span></a></li> -->
        </ul>
      </nav><!-- .nav-menu -->
    </div>
  </header><!-- End Header -->

<main id="main">

        <!-- ======= Breadcrumbs ======= -->
        <section id="breadcrumbs" class="breadcrumbs">
          <div class="container">
    
            <div class="d-flex justify-content-between align-items-center">
              <h2>Data-Engineering</h2>
              <ol>
                <li><a href="Data-engineering.html" class="clickable-box">Content section</a></li>
                <li><a href="index.html#portfolio" class="clickable-box">Portfolio section</a></li>
              </ol>
            </div>
    
          </div>
        </section><!-- End Breadcrumbs -->

    <!------  right dropdown menue ------->
    <div class="right-side-list">
      <div class="dropdown">
          <button class="dropbtn"><strong>Shortcuts:</strong></button>
          <div class="dropdown-content">
              <ul>
                  <li><a href="cloud-compute.html"><i class="fas fa-cloud"></i> Cloud</a></li>
                  <li><a href="AWS-GCP.html"><i class="fas fa-cloud"></i> AWS-GCP</a></li>
                  <li><a href="amazon-s3.html"><i class="fas fa-cloud"></i> AWS S3</a></li>
                  <li><a href="ec2-confi.html"><i class="fas fa-server"></i> EC2</a></li>
                  <li><a href="Docker-Container.html"><i class="fab fa-docker" style="color: rgb(29, 27, 27);"></i> Docker</a></li>
                  <li><a href="Jupyter-nifi.html"><i class="fab fa-python" style="color: rgb(34, 32, 32);"></i> Jupyter-nifi</a></li>
                  <li><a href="snowflake-task-stream.html"><i class="fas fa-snowflake"></i> Snowflake</a></li>
                  <li><a href="data-model.html"><i class="fas fa-database"></i> Data modeling</a></li>
                  <li><a href="sql-basics.html"><i class="fas fa-table"></i> QL</a></li>
                  <li><a href="sql-basic-details.html"><i class="fas fa-database"></i> SQL</a></li>
                  <li><a href="Bigquerry-sql.html"><i class="fas fa-database"></i> Bigquerry</a></li>
                  <li><a href="scd.html"><i class="fas fa-archive"></i> SCD</a></li>
                  <li><a href="sql-project.html"><i class="fas fa-database"></i> SQL project</a></li>
                    <!-- Add more subsections as needed -->
                </ul>
          </div>
        </div>
    </div>

    <!-- ======= Portfolio Details Section ======= -->
    <section id="portfolio-details" class="portfolio-details">
      <div class="container">
        <div class="row gy-4">
          <h1>Unit Testing : Software Development</h1>
          <div class="col-lg-8">
            
            <div class="portfolio-details-slider swiper">
              <div class="swiper-wrapper align-items-center">

                <div class="swiper-slide">
                    
                  <figure>
                    <img src="assets/img/data-engineering/unit-testing-stages.png" alt="" style="max-width: 50%; max-height: 50%;">
                    <figcaption></figcaption>
                  </figure>
                </div>

              </div>
            <div class="swiper-pagination"></div>
          </div>
        </div>

        <div class="col-lg-4 grey-box">
          
          <div class="section-title">
            <h3>Content</h3>
            <ol>
              <li><a href="#introduction">Introduction</a>
              <li><a href="#Unit-testing">Unit testing</a></li>
              <li><a href="#reference">Reference</a></li>
          </ol>
          </div>
        </div>
      </div>

      <section id="introduction">
        <h2>Introduction</h2>
        Unit testing is a software testing technique where individual units or components of a software application are tested in isolation. The main purpose is to validate that each unit of the software 
        performs as designed. In data science and analytics, unit testing can be applied to functions, modules, or algorithms to ensure they produce the expected output for a given set of inputs. It helps 
        identify and fix bugs early in the development process, improving the overall reliability and maintainability of the code. 

        <div class="box">
          <ul>
            <li><strong>Reference: </strong>For more details, please checkout my github repo: <a href="https://github.com/arunp77/Data-engineering-tools/tree/main/Unit-test" target="_blank">Unit testing</a>.</li>
            <li><strong>Note: </strong>
              For the difference between the <code>unittest</code> and <code>pytest</code>, please visit the repo and the readme file in <a href="https://github.com/arunp77/Data-engineering-tools/blob/main/Unit-test/unittest_pytest.md" target="_blank">Unittesting and pytest differences</a>.</li>
          </ul>
        </div>
        

      <section>
        <h4>Unit testing vs integration testing</h4> 
        While unit testing ensures that all units of code properly work independently, integration testing ensures that they work together. Integration tests focus on real-life use cases. They often rely on external data such as databases or web servers.

        A unit test, on the other hand, only needs data that is created exclusively for the test. It is therefore much easier to implement.
        <table>
          <tr>
            <th></th>
            <th>Unit testing</th>
            <th>integration testing</th>
          </tr>
          <tr>
            <td>Scope</td>
            <td>
              <ul>
                <li>Focuses on testing individual units or components of a software application in isolation.</li>
                <li>Units can be functions, methods, or small modules</li>
              </ul>
            </td>
            <td>
              <ul>
                <li>Involves testing the interactions and interfaces between multiple components or systems.</li>
                <li>Ensures that integrated components work together as expected.</li>
              </ul>
            </td> 
          </tr>
          <tr>
            <td>Isolation</td>
            <td>
              <ul>
                <li>Performed in isolation from the rest of the application.</li>
                <li>Dependencies are often replaced with mocks or stubs to focus on the specific unit being tested.</li>
              </ul>
            </td>
            <td>
              <ul>
                <li>Requires multiple components to be integrated and tested as a group.</li>
                <li>Tests how well different components work together.</li>
              </ul>
            </td> 
          </tr>
          <tr>
            <td>Purpose</td>
            <td>
              <ul>
                <li>Identifies and fixes bugs in individual units early in the development process.</li>
                <li>Helps maintain code quality and allows for easier refactoring.</li>
              </ul>
            </td>
            <td>
              <ul>
                <li>Verifies that integrated components function correctly as a whole.</li>
                <li>Detects issues arising from the interactions between components.</li>
              </ul>
            </td> 
          </tr>
          <tr>
            <td>Execution Time</td>
            <td>Typically faster to execute as it involves testing smaller units of code.</td>
            <td>May take longer to execute due to the need to integrate and test larger portions of the application.</td> 
          </tr>
          <tr>
            <td>Dependencies</td>
            <td>Dependencies are often mocked or stubbed to isolate the unit under test.</td>
            <td>Requires actual dependencies to be present for testing the integrated system.</td> 
          </tr>
          <tr>
            <td>Automation</td>
            <td>Easily automated, and it's common to run unit tests frequently during development.</td>
            <td>Automation is also common but may involve more complex setups and configurations.</td> 
          </tr>
          <tr>
            <td>Debugging</td>
            <td>Easier to pinpoint issues to specific units or components.</td>
            <td>May require more effort to identify the specific cause of failures due to interactions between components.</td> 
          </tr>
        </table>

        <h4>Advantages of Unit testing</h4>
        Here is a non-exhaustive list of the advantages of unit testing that make it a vital asset in the toolbox of a good programmer:
        <ul>
          <li><strong>Time saving: </strong>Some very basic errors can become quite difficult to identify during the integration testing phase, due to the many layers of code that accumulate. However, these errors can be detected very simply, very quickly and very early in the building of the code thanks to unit tests.</li>
          <li><strong>Fluidification of code changes: </strong>If you wish to bring in a modification to your code (e.g. change the regression method), it becomes very easy to verify that the function still works as expected by performing the unit test of this function.</li>
          <li><strong>Improved code quality: </strong>A good approach to coding is to code unit tests before you code the units themselves. This compels one to think about all the contingencies that the unit might face. Thinking about how to code the unit renders the unit simpler and more robust later on. This approach is known as test driven development (TDD).</li>
          <li><strong>Aid to the understanding of the code: </strong>Unit tests are also used by developers as explanatory documentation of each part of the code. In fact, it is very easy to understand the expected behaviour of a function by reading the associated unit test beforehand.</li>
        </ul>

        <h4>Weakness of the Unit testing</h4>
        <ul>
          <li>However, it is impossible to test the infinite variety of contingencies that the unit might face. Passing the unit test without a hitch is therefore not a total guarantee of correct operation.</li>
          <li>Unit tests cannot, however, by construction, test the interaction between units.</li>
        </ul>

        <h4>Automated testing</h4>
        <ul>
          <li><strong>What is automated testing? :</strong>
            To automate unit tests, there are frameworks that will greatly facilitate the task. The developer must set the criteria for the tests he/she wishes to perform, and then the framework takes care of performing the tests automatically and providing detailed error reports.
            <ul>
              <li><strong>unitest:</strong> The basic framework for automated testing on python is <code>unittest</code>. It is a built-in testing framework in python. It follows the xUnit style and provides classes and methods for creating and running tests.</li>
              <li><strong>pytest: </strong><code>pytest</code> is another popular third party testing framework. It normaly simplifues test discovery
                and execution. It's known for its concise syntex and powerful features.</li>
              <li><strong>nose: </strong>Similarly <code>nose</code> is another third party testing framewrok that extends unittest and provides additional functionality. It's particularly useful for test discovery and running tests in parallel.</li>
            </ul>
        </ul>

        <br>
        
        <hr>
        <strong>Example-1</strong>
        <ul>
          <li>Create <code>calculator.py</code> file. Here we will have add function.
          <pre><code class="language-python">
            def add(a,b):
            return a+b
          </code></pre>
          </li>
          <li>Create a <code>test_calculator.py</code> file and add the code:
            <pre><code class="language-python">
              import pytest
              from calculator import add

              def test_add_positive_numbers():
                  result = add(2, 3)
                  assert result == 5

              def test_add_negative_numbers():
                  result = add(-2, -3)
                  assert result == -5

              def test_add_mixed_numbers():
                  result = add(1, -5)
                  assert result == -4
            </code></pre>
            This file contains test functions prefixed with <code>test_</code>. The <code>pytest</code> framework for assertions ('assert') instead of the built-in <code>unittest</code> assertions. 
          </li>
          <li>Now run the tests using:
            <pre>pytest test_calculator.py</pre>
            Pytest will discover and run the tests, providing detailed output.
          </li>
        </ul>
        <figure>
          <img src="assets/img/data-engineering/pytest.png" alt="" style="max-width: 90%; max-height: auto;">
          <figcaption style="text-align: center;">pytest result.</figcaption>
        </figure>
        If we change one of the test, it will show an error and hence we will know that which test don't satisfy.  The green dot turned into a red because one of the checks in the test was not carried out.
        The error returned is an assertion error and Pytest even tells us exactly where it is. When we change result: <code>result = add(2,3) ==6</code>,
        it will give error: 
        <figure>
          <img src="assets/img/data-engineering/testing_cal.png" alt="" style="max-width: 90%; max-height: auto;">
          <figcaption style="text-align: center;">pytest result.</figcaption>
        </figure>

        <br>
        <hr>
        <strong>Example-2:</strong>
        Let's create a class 'Wallet' that has a method for adding money <code>add_cash</code> and a method for withdrawing money <code>spend_cash</code>. 
        In a <code>wallet.py</code> file, create a Wallet class that:
        <ul>
          <li>Accepts an initial <code>contribution</code> of money and stores it in the <code>balance</code> attribute (= 0 if the initial contribution is not specified)</li>
          <li>Has a method for adding money <code>add_cash</code>.</li>
          <li>Has a method for withdrawing money <code>spend_cash</code>. This method first checks that the balance is sufficient and returns an <code>InsufficientAmount</code> exception if it is not.</li>
        </ul>
        In another python file wallet_test.py we will now write our unit tests. To do this we need to import the functions we want to test as well as the pytest module (to test the InsufficientAmount exception).
        <br>
        <strong>Solution:</strong>
        The wallet.py file then contains:
        <pre><code class="language-python">
          class Wallet(object):

          def __init__(self, initial_amount=0):
              self.balance = initial_amount
      
          def spend_cash(self, amount):
              if self.balance < amount:
                  raise InsufficientAmount('Not enough available to spend {}'.format(amount))
              self.balance -= amount
      
          def add_cash(self, amount):
              self.balance += amount
      
          class InsufficientAmount(Exception):
              pass
        </code></pre>
        In another python file wallet_test.py we will now write our unit tests. To do this we need to import the functions we want to test as well as the pytest module (to test the InsufficientAmount exception).
        Now write 5 unit tests that check different properties :
        <ul>
          <li>a newly created wallet has a balance of 0 by default.</li>
          <li>a newly created wallet with an initial balance of 100 has a balance of 100.</li>
          <li>a wallet created with an initial balance of 10 to which 90 is added has a balance of 100.</li>
          <li>a wallet created with an initial balance of 20 from which 10 is removed has a balance of 10.</li>
          <li>a wallet that tries to spend more than its balance will cause an InsufficientAmount error message.</li>
        </ul>
        the <code>wallet_test.py</code> contains:
        <pre><code class="language-python">
          from wallet import Wallet, InsufficientAmount
          import pytest
          def test_default_initial_amount():
              wallet = Wallet()
              assert wallet.balance == 0
      
          def test_setting_initial_amount():
              wallet = Wallet(100)
              assert wallet.balance == 100
          
          def test_wallet_add_cash():
              wallet = Wallet(10)
              wallet.add_cash(90)
              assert wallet.balance == 100
          
          def test_wallet_spend_cash():
              wallet = Wallet(20)
              wallet.spend_cash(10)
              assert wallet.balance == 10
          
          def test_wallet_spend_cash_raises_exception_on_insufficient_amount():
              wallet = Wallet()
              with pytest.raises(InsufficientAmount):
                  wallet.spend_cash(100)
        </code></pre>
        <figure>
          <img src="assets/img/data-engineering/wallet-test.png" alt="" style="max-width: 90%; max-height: auto;">
          <figcaption style="text-align: center;">pytest result.</figcaption>
        </figure>

        <br>
        <hr>
        <strong>Example-4:</strong>
        We can calculate the sum of the two number in following three ways:
        <ul>
          <li>Without Parametrization or Fixture</li>
          <li>Only With Parameterization</li>
          <li> Only With Fixture</li>
        </ul>
        The three methods are used for different purpose.
        <ul>
          <li><strong>Without Any Parameterization or Fixture:</strong>
            In this approach, each test case is written as an individual function, and there is no use of parameterization or fixtures. Each test explicitly defines its input values and expected outcomes. This approach is straightforward and may be suitable for simpler test cases or scenarios where explicitness is preferred. However, it can lead to code duplication if many test cases share a similar structure.
            <pre><code class="language-python">
              # test_example.py

              def add(a, b):
                  return a + b
              
              def test_addition_case1():
                  result = add(1, 2)
                  assert result == 3
              
              def test_addition_case2():
                  result = add(0, 0)
                  assert result == 0
              
              def test_addition_case3():
                  result = add(-1, 1)
                  assert result == 0
              
              def test_addition_case4():
                  result = add(10, -5)
                  assert result == 5              
            </code></pre>
          </li>
          <li><strong>Only With Fixture: </strong>
            In this approach, a fixture is used to provide parameterized input data for a test function. The @pytest.fixture decorator defines a fixture that can be reused across multiple test functions. This enhances code modularity and reusability by separating the test setup from the test logic.
            <pre><code class="language-python">
              import pytest

              @pytest.fixture(params=[
                  (1, 2, 3),
                  (0, 0, 0),
                  (-1, 1, 0),
                  (10, -5, 5),
              ])
              def input_data(request):
                  return request.param
              
              def test_addition(input_data):
                  input_a, input_b, expected_output = input_data
                  result = add(input_a, input_b)
                  assert result == expected_output
            </code></pre>
          </li>
          <li><strong>Only With Parameterization: </strong>
            In this approach, the @pytest.mark.parametrize decorator is used to parametrize a single test function. The decorator allows you to run the same test function with different sets of input parameters. This results in more concise code, especially when dealing with similar test cases, and helps reduce code duplication.
            <pre><code class="language-python">
              import pytest

              @pytest.mark.parametrize("input_a, input_b, expected_output", [
                  (1, 2, 3),
                  (0, 0, 0),
                  (-1, 1, 0),
                  (10, -5, 5),
              ])
              def test_addition(input_a, input_b, expected_output):
                  result = add(input_a, input_b)
                  assert result == expected_output
            </code></pre>
          </li>
        </ul>
        
        <hr>
        <br>
        
        <h3>Side effects:</h3>
        Unit tests can have both positive and negative side effects, depending on how they are implemented and maintained. Here are some of the common side effects:
        <ol>
          <li><strong>Positive Side Effects: </strong>
            <ul>
              <li><strong>Improved Code Quality: </strong>
                <ul>
                  <li>Writing unit tests encourages developers to create modular and well-structured code.</li>
                  <li>Forces developers to think about how to make functions and modules easily testable.</li>
                </ul>
              </li>
              <li><strong>Early Bug Detection: </strong>
                <ul>
                  <li>Identifying and fixing bugs early in the development process is one of the primary benefits of unit testing.</li>
                  <li>Helps catch issues before they escalate into larger problems.</li>
                </ul>
              </li>
              <li><strong>Regression Prevention: </strong>
                <ul>
                  <li>Unit tests act as a safety net to ensure that new code changes do not break existing functionality (regression testing).</li>
                </ul>
              </li>
              <li><strong>Documentation: </strong>
                <ul>
                  <li>Unit tests serve as living documentation, showcasing the expected behavior of the code.</li>
                  <li>New developers can use tests to understand the intended functionality of different parts of the codebase.</li>
                </ul>
              </li>
              <li><strong>Facilitates Refactoring: </strong>
                <ul>
                  <li>Developers can confidently refactor code, knowing that if the tests pass, the changes haven't introduced regressions.</li>
                </ul>
              </li>
              <li><strong>Supports Continuous Integration: </strong>
                <ul>
                  <li>Unit tests are crucial for setting up continuous integration (CI) pipelines, ensuring that tests are automatically run whenever changes are made.</li>
                </ul>
              </li>
            </ul>
          </li>
          <li><strong>Negative Side Effects:</strong>
            <ul>
              <li><strong>Time-Consuming: </strong>
                <ul>
                  <li>Writing and maintaining unit tests can be time-consuming, especially for complex systems.</li>
                  <li>Balancing test coverage with development speed is crucial.</li>
                </ul>
              </li>
              <li><strong>False Sense of Security: </strong>
                <ul>
                  <li>High test coverage does not guarantee bug-free code. It's possible to have well-tested code that still has logical errors or edge cases that are not covered.</li>
                </ul>
              </li>
              <li><strong>Maintenance Overhead: </strong>
                <ul>
                  <li>As the codebase evolves, unit tests may need to be updated or rewritten to accommodate changes.</li>
                  <li>Frequent changes in requirements might result in a constant need for test updates.</li>
                </ul>
              </li>
              <li><strong>Overemphasis on Code Coverage: </strong>
                <ul>
                  <li>Focusing solely on achieving high code coverage may lead to tests that don't adequately cover critical scenarios.</li>
                  <li>Quality of tests is more important than sheer quantity.</li>
                </ul>
              </li>
              <li><strong>Dependency on Implementation Details: </strong>
                <ul>
                  <li>Tests that are too tightly coupled with the implementation details of the code may become fragile and break easily with minor changes.</li>
                </ul>
              </li>
              <li><strong>Resistance to Change: </strong>
                <ul>
                  <li>In some cases, developers may resist making changes to the code due to concerns about breaking existing tests.</li>
                </ul>
              </li>
            </ul>
          </li>
        </ol>
        If your units contain a lot of side effects this can be problematic for unit testing. Unit testing is a good way to ensure that your units respect the Single Responsibility Principle.

        <h4>Error messages</h4>
        Error messages and their handling can vary based on the nature of the functions being tested. Here are some common types of error messages and how they might be handled in unit tests:
        <ol>
          <li><strong><code>ValueError</code> invalid Input:</strong>
          <pre><code class="language-python">
            def divide(a, b):
            if b == 0:
                raise ValueError("Cannot divide by zero.")
            return a / b
          </code></pre>
          <strong>Handling:</strong>
          <pre><code class="language-python">
            def test_divide():
            assert divide(10, 2) == 5
            try:
                divide(5, 0)
            except ValueError as e:
                assert str(e) == "Cannot divide by zero."
          </code></pre>
          </li>
          <li><strong>TypeError: Incorrect Argument Type:</strong>
            <pre><code class="language-python">
              def calculate_square(n):
              if not isinstance(n, (int, float)):
                  raise TypeError("Input must be a number.")
              return n ** 2          
            </code></pre>
            <strong></strong>
            <pre><code class="language-python">
              def test_calculate_square():
              assert calculate_square(3) == 9
              try:
                  calculate_square("four")
              except TypeError as e:
                  assert str(e) == "Input must be a number."
            </code></pre>
          </li>
          <li><strong>AssertionError: Unexpected Output:</strong>
            <pre><code class="language-python">
              def add(a, b):
              return a * b  # Incorrect implementation
            </code></pre>
            <strong>Handling:</strong>
            <pre><code class="language-python">
              def test_add():
              assert add(2, 3) == 5
              try:
                  assert add(2, 3) == 6
              except AssertionError as e:
                  assert str(e) == "assert 6 == 5"
            </code></pre>
          </li>
          <li><strong>IndexError: Out of Range:</strong>
            <pre><code class="language-python">
              def get_element_by_index(lst, index):
              if index < 0 or index >= len(lst):
                  raise IndexError("Index out of range.")
              return lst[index]
            </code></pre>
            <strong>Handling:</strong>
            <pre><code class="language-python">
              def test_get_element_by_index():
              my_list = [1, 2, 3]
              assert get_element_by_index(my_list, 1) == 2
              try:
                  get_element_by_index(my_list, 5)
              except IndexError as e:
                  assert str(e) == "Index out of range."
            </code></pre>
          </li>
          <li><strong>CustomError: Specific Application Error:</strong>
            <pre><code class="language-python">
              class CustomError(Exception):
              pass
          
              def custom_function():
                  raise CustomError("Something went wrong.")
            </code></pre>
            <strong>Handling:</strong>
            <pre><code class="language-python">
              def test_custom_function():
              try:
                  custom_function()
              except CustomError as e:
                  assert str(e) == "Something went wrong."
            </code></pre>
          </li>
        </ol>


      </section>
        


      <!-------Reference ------->
      <section id="reference">
        <h2>References</h2>
        <ul>
          <a href="https://github.com/arunp77/Data-engineering-tools/tree/main/Unit-test" target="_blank">Unit testing</a>
          <li><a href="https://arunp77.medium.com/ensuring-data-integrity-and-continuity-for-machine-learning-projects-c4335eb1e9f9" target="_blank">Ensuring Data Integrity and Continuity for Machine Learning Projects.</a></li>
          <li><a href="https://www.jenkins.io/doc/tutorials/" target="_blank">Jenkins documentation</a></li>
          <li><a href="https://softwaresennin.medium.com/creating-our-first-complete-jenkins-ci-cd-pipeline-995a22934a35" target="_blank">Blogpost: Creating our First Complete Jenkins CI/CD Pipeline</a></li>
        </ul>
      </section>

      <hr>
      
      <div style="background-color: #f0f0f0; padding: 15px; border-radius: 5px;">

        <h3>Some other interesting things to know:</h3>
        <ul style="list-style-type: disc; margin-left: 30px;">
            <li>Visit my website on <a href="sql-project.html">For Data, Big Data, Data-modeling, Datawarehouse, SQL, cloud-compute.</a></li>
            <li>Visit my website on <a href="Data-engineering.html">Data engineering</a></li>
        </ul>
      </div>
      <p></p>

      <div class="navigation">
          <a href="index.html#portfolio" class="clickable-box">
              <span class="arrow-left">Portfolio section</span>
          </a>
          
          <a href="Data-engineering.html" class="clickable-box">
              <span class="arrow-right">Content</span>
          </a>
      </div>
  </div>
</div>
</section><!-- End Portfolio Details Section -->
</main><!-- End #main --

<!-- ======= Footer ======= -->
<footer id="footer">
  <div class="container">
    <div class="copyright">
      &copy; Copyright <strong><span>Arun</span></strong>
    </div>
  </div>
</footer><!-- End  Footer -->

<a href="#" class="back-to-top d-flex align-items-center justify-content-center"><i class="bi bi-arrow-up-short"></i></a>

<!-- Vendor JS Files -->
<script src="assets/vendor/purecounter/purecounter_vanilla.js"></script>
<script src="assets/vendor/aos/aos.js"></script>
<script src="assets/vendor/bootstrap/js/bootstrap.bundle.min.js"></script>
<script src="assets/vendor/glightbox/js/glightbox.min.js"></script>
<script src="assets/vendor/isotope-layout/isotope.pkgd.min.js"></script>
<script src="assets/vendor/swiper/swiper-bundle.min.js"></script>
<script src="assets/vendor/typed.js/typed.umd.js"></script>
<script src="assets/vendor/waypoints/noframework.waypoints.js"></script>
<script src="assets/vendor/php-email-form/validate.js"></script>

<!-- Template Main JS File -->
<script src="assets/js/main.js"></script>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    hljs.initHighlightingOnLoad();
  });
</script>

</body>

</html>